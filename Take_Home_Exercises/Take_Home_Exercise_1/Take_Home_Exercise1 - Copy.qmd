---
title: "Take_Home Exercise 1: Geospatial Analytics for Social Good: Application of Spatial and Spatio-temporal Point Patterns Analysis to discover the geographical distribution of Armed Conflict in Myanmar"
author: "Jiale SO"
date: "August 22, 2024"
date-modified: "last-modified"
execute: 
  eval: true
  echo: true #not seeing the code chunka
  freeze: true
  warning: false
  preview: false
  execute: false
---

# 1.0 Introduction

The study of armed conflicts in Myanmar has gained critical importance in understanding the geographical distribution and intensity of violence across different regions. Myanmar's complex ethnic composition and ongoing civil strife make it a unique case for geospatial analysis. This project aims to apply **spatial and spatio-temporal point pattern analysis** methods to uncover the patterns of armed conflict between January 2021 and June 2024.

By leveraging conflict data from the Armed Conflict Location & Event Data [(ACLED)](https://acleddata.com/) and geospatial tools, we will focus on visualizing and interpreting conflict density through heat maps, Kernel Density Estimation (KDE), and advanced spatio-temporal analysis.

![](images/clipboard-2109894583.png)

Our analysis will focus on four types of conflict events:

1.  **Battles**,
2.  **Explosion/Remote violence**,
3.  **Strategic developments**,
4.  **Violence against civilians**,

with particular attention paid to quarterly patterns in conflict occurrence.

# 2.0 Setting Up The Environment & Dataset

## 2.1 Installing the required Packages

**Key Packages Used in the Project:**

1.  **`sf`**: Handles simple features in R, allowing for spatial data manipulation and analysis. It is crucial for reading and managing geospatial data like shapefiles (e.g., Myanmar’s administrative boundaries).

2.  **`raster`**: Used for raster-based spatial data manipulation, especially for working with raster maps, such as Kernel Density Estimation (KDE) results.

3.  **`spatstat`**: A powerful package for spatial point pattern analysis. It helps to analyze and visualize spatial point data, particularly for identifying clusters or patterns in armed conflict events.

4.  **`sparr`**: Builds on `spatstat` and focuses on performing spatial and spatio-temporal kernel smoothing, which will be crucial for KDE and heatmap creation.

5.  **`tmap`**: A thematic mapping package that will allow us to create maps, including KDE visualizations on an OpenStreetMap base.

6.  **`tidyverse`**: A collection of data manipulation packages like `dplyr`, `ggplot2`, and `purrr`. It’s essential for data cleaning, manipulation, and visualization tasks.

7.  **`stpp`**: Used for spatio-temporal point pattern analysis, crucial for analyzing how conflict events evolve in both space and time.

8.  **`skimr`**: A quick and comprehensive tool to provide summaries and descriptive statistics for datasets, helping in the initial exploration.

9.  **`gganimate`**: Extends `ggplot2` to create animated visualizations. We can use this for animated time-series or evolving conflict maps.

10. **`ggplot2`**: The core plotting package in R, essential for creating visualizations like time series plots and KDE heatmaps.

11. **`plotly`**: Useful for creating interactive visualizations, allowing users to explore spatial data interactively (e.g., hover over points to see conflict details).

12. `pacman`: is a package management tool in R designed to streamline the process of loading and installing packages.

```{r, eval = TRUE}
pacman::p_load(sf, raster, spatstat, sparr, tmap, tidyverse, stpp, skimr, gganimate, ggplot2, plotly, flexdashboard, DT,gridExtra, rlist, grid,future)
```

## 2.2 Data-set involved in this topic

For this analysis, we use two key datasets:

### 2.2.1 **ACLED Armed Conflict Data**

[Location & Event Data (ACLED)](https://acleddata.com/data-export-tool/)platform, which maintains an extensive record of conflict events globally. For this specific analysis, we will limit the dataset by filtering based on the following parameters to streamline data preparation and minimize the need for extensive data cleaning:

+----------------+----------------------------------------+
| Data Parameter | Filter Category                        |
+================+========================================+
| Date Range     | From **01/01/2021** to **30/06/2024**. |
+----------------+----------------------------------------+
| Event Type     | 1\. Battles\                           |
|                | 2. Violence Against Civilians\         |
|                | 3. Explosions/Remote Violence\         |
|                | 4. Strategic Developments              |
+----------------+----------------------------------------+
| Country        | Myanmar                                |
+----------------+----------------------------------------+

<details>

<summary>ACLED Configuration Image</summary>

![](images/ACLEDConfiguration.png)

</details>

<details>

<summary>Code to Import ACLED Dataset</summary>

```{r, eval = TRUE }
ACLEDData <- read_csv("data/raw/aspatial/2021-01-01-2024-06-30-Myanmar.csv")
```

</details>

#### 2.2.1.1 Understanding the data set fields.

Referencing this [ACLED Official codebook,](https://acleddata.com/knowledge-base/codebook/#violence-against-civilians) this is the dataset that we are working with, not to bore you with the details are mainly interested in the following fields,

-   **Event ID**: Unique identifier for each conflict event.

-   **Event Date**: Date of occurrence.

-   **Event Type**: Type of conflict event (e.g., Battles, Remote Violence).

-   **Latitude/Longitude**: Coordinates of the event.

-   **Fatalities**: Number of fatalities resulting from the event.

-   **Actors**: The groups or individuals involved in the conflict (e.g., state actors, ethnic armed groups).

-   **Admin Levels**: Administrative region, district, and township where the event took place.

If you're interested in the data set fields to explore more, here's the full fields!

<details>

<summary>ACLED Full Table Fields Summary</summary>

|                    |                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                  |
|--------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Fields name**    | **Fields Description**                                                                                                                                                                                                                                                           | **Values**                                                                                                                                                                                                       |
| event_id_cnty      | A unique alphanumeric event identifier by number and country acronym. This identifier remains constant even when the event details are updated.                                                                                                                                  | E.g. ETH9766                                                                                                                                                                                                     |
| event_date         | The date on which the event took place. Recorded as Year-Month-Day.                                                                                                                                                                                                              | E.g. 2023-02-16                                                                                                                                                                                                  |
| year               | The year in which the event took place.                                                                                                                                                                                                                                          | E.g. 2018                                                                                                                                                                                                        |
| time_precision     | A numeric code between 1 and 3 indicating the level of precision of the date recorded for the event. The higher the number, the lower the precision.                                                                                                                             | 1, 2, or 3; with 1 being the most precise.                                                                                                                                                                       |
| disorder_type      | The disorder category an event belongs to.                                                                                                                                                                                                                                       | Political violence, Demonstrations, or Strategic developments.                                                                                                                                                   |
| event_type         | The type of event; further specifies the nature of the event.                                                                                                                                                                                                                    | [E.g. BattlesFor the full list of ACLED event types, see the ACLED Event Types table.](https://acleddata.com/knowledge-base/codebook/#events-table)                                                              |
| sub_event_type     | A subcategory of the event type.                                                                                                                                                                                                                                                 | [E.g. Armed clashFor the full list of ACLED sub-event types, see the ACLED Event Types table.](https://acleddata.com/knowledge-base/codebook/#events-table)                                                      |
| actor1             | [One of two main actors involved in the event (does not necessarily indicate the aggressor).](https://acleddata.com/resources/quick-guide-to-acled-data/#s22)                                                                                                                    | E.g. Rioters (Papua New Guinea)                                                                                                                                                                                  |
| assoc_actor_1      | Actor(s) involved in the event alongside ‘Actor 1’ or actor designations that further identify ‘Actor 1’.                                                                                                                                                                        | E.g. Labor Group (Spain); Women (Spain)Can have multiple actors separated by a semicolon, or can be blank.                                                                                                       |
| inter1             | [A numeric code between 0 and 8 indicating the type of ‘Actor 1’ (for more, see the section Actor Names, Types, and ‘Inter’ Codes).](https://acleddata.com/knowledge-base/codebook/#actor-names-types-and-inter-codes)                                                           | 1, 2, 3, 4, 5, 6, 7, or 8.                                                                                                                                                                                       |
| actor2             | [One of two main actors involved in the event (does not necessarily indicate the target or victim).](https://acleddata.com/resources/quick-guide-to-acled-data/#s22)                                                                                                             | E.g. Civilians (Kenya)Can be blank.                                                                                                                                                                              |
| assoc_actor_2      | Actor(s) involved in the event alongside ‘Actor 2’ or actor designation further identifying ‘Actor 2’.                                                                                                                                                                           | E.g. Labor Group (Spain); Women (Spain)Can have multiple actors separated by a semicolon, or can be blank.                                                                                                       |
| inter2             | [A numeric code between 0 to 8 indicating the type of ‘Actor 2’ (for more, see the section Actor Names, Types, and ‘Inter’ Codes).](https://acleddata.com/knowledge-base/codebook/#actor-names-types-and-inter-codes)                                                            | 0, 1, 2, 3, 4, 5, 6, 7, or 8.                                                                                                                                                                                    |
| interaction        | [A two-digit numeric code (combination of ‘Inter 1’ and ‘Inter 2’) indicating the two actor types interacting in the event (for more, see the section Actor Names, Types, and ‘Inter’ Codes).](https://acleddata.com/knowledge-base/codebook/#actor-names-types-and-inter-codes) | E.g.3, 58                                                                                                                                                                                                        |
| civilian_targeting | This column indicates whether the event involved civilian targeting.                                                                                                                                                                                                             | Either ‘Civilians targeted’ or blank.                                                                                                                                                                            |
| iso                | [A unique three-digit numeric code assigned to each country or territory according to ISO 3166.](https://www.iso.org/iso-3166-country-codes.html)                                                                                                                                | E.g. 231 for Ethiopia                                                                                                                                                                                            |
| region             | The region of the world where the event took place.                                                                                                                                                                                                                              | E.g. Eastern Africa                                                                                                                                                                                              |
| country            | The country or territory in which the event took place.                                                                                                                                                                                                                          | E.g. Ethiopia                                                                                                                                                                                                    |
| admin1             | The largest sub-national administrative region in which the event took place.                                                                                                                                                                                                    | E.g. Oromia                                                                                                                                                                                                      |
| admin2             | The second largest sub-national administrative region in which the event took place.                                                                                                                                                                                             | E.g. ArsiCan be blank.                                                                                                                                                                                           |
| admin3             | The third largest sub-national administrative region in which the event took place.                                                                                                                                                                                              | E.g. MertiCan be blank.                                                                                                                                                                                          |
| location           | The name of the location at which the event took place.                                                                                                                                                                                                                          | E.g. Abomsa                                                                                                                                                                                                      |
| latitude           | The latitude of the location in four decimal degrees notation (EPSG:32647).                                                                                                                                                                                                      | E.g. 8.5907                                                                                                                                                                                                      |
| longitude          | The longitude of the location in four decimal degrees notation (EPSG:32647).                                                                                                                                                                                                     | E.g. 39.8588                                                                                                                                                                                                     |
| geo_precision      | A numeric code between 1 and 3 indicating the level of certainty of the location recorded for the event. The higher the number, the lower the precision.                                                                                                                         | 1, 2, or 3; with 1 being the most precise.                                                                                                                                                                       |
| source             | The sources used to record the event. Separated by a semicolon.                                                                                                                                                                                                                  | E.g. Ansar Allah; Yemen Data Project                                                                                                                                                                             |
| source\_ scale     | [An indication of the geographic closeness of the used sources to the event (for more, see the section Source Scale).](https://acleddata.com/knowledge-base/codebook/#source-scale)                                                                                              | E.g. Local partner-National                                                                                                                                                                                      |
| notes              | A short description of the event.                                                                                                                                                                                                                                                | E.g. On 16 February 2023, OLF-Shane abducted an unidentified number of civilians after stopping a vehicle in an area near Abomsa (Merti, Arsi, Oromia). The abductees were traveling from Adama to Abomsa, Arsi. |
| fatalities         | The number of reported fatalities arising from an event. When there are conflicting reports, the most conservative estimate is recorded.                                                                                                                                         | E.g. 3No information on fatalities is recorded as 0 reported fatalities.                                                                                                                                         |
| tags               | Additional structured information about the event. Separated by a semicolon.                                                                                                                                                                                                     | E.g. women targeted: politicians; sexual violence                                                                                                                                                                |
| timestamp          | [An automatically generated Unix timestamp that represents the exact date and time an event was uploaded to the ACLED API.](https://www.unixtimestamp.com/)                                                                                                                      | E.g. 1676909320                                                                                                                                                                                                  |

</details>

### **2.2.2 Myanmar Administrative Boundaries (Shapefiles)**:

Obtained through [Geonode Mimu](https://geonode.themimu.info/layers/geonode%3Ammr_polbnda_adm2_250k_mimu), this shapefile helps us to build the map and set the boundary zone of each district of myanmar. This dataset provides the geographical boundaries of Myanmar's administrative divisions, from the national level down to the township level. It is essential for mapping conflict events to specific regions.

::: callout-note
***Myanmar has State, District and Township level, why District Level?***

Choosing the **district level** over the **township level** for conflict analysis provides a better balance between detail and clarity. The district level allows us to capture broader regional trends without overwhelming the analysis with too many granular data points, as township-level data can be overly detailed. It also improves **computational efficiency** and makes visualizations clearer, while still offering enough specificity to reveal conflict hotspots. Additionally, population and auxiliary data are more readily available at the district level, making the analysis more consistent and manageable.
:::

<details>

<summary>Code to Import Shapefile Dataset</summary>

::: panel-tabset
## State

```{r}
M_State_Sf <- st_read(dsn="data/raw/geospatial/stateLevel", layer = "mmr_polbnda_adm1_250k_mimu_1") 
M_State_Sf
```

## District

```{r}
M_District_Sf <- st_read(dsn="data/raw/geospatial", layer = "mmr_polbnda_adm2_250k_mimu") 
M_District_Sf
```
:::

</details>

#### 2.2.2.1 Understanding the data set fields.

|            |                                                                                                                                                                                                                                      |
|------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Field Name | Description                                                                                                                                                                                                                          |
| OBJECTID   | This is a unique identifier for each feature in the dataset, typically used to identify individual records or polygons in the shapefile.                                                                                             |
| ST         | This represents the State or Region in Myanmar. For example, in your dataset, "Ayeyarwady" refers to a state/region.                                                                                                                 |
| ST_PCODE   | This stands for State Postal Code. It is a standardized code that represents each state or region in Myanmar, such as "MMR017" for Ayeyarwady.                                                                                       |
| DT         | This stands for District or Township within the respective state/region. For example, "Hinthada" is a district or township within Ayeyarwady.                                                                                        |
| DT_PCODE   | This stands for District/Township Postal Code. It is a standardized postal code for each district or township, such as "MMR017D002" for the Hinthada district/township in Ayeyarwady.                                                |
| DT_MMR     | This field could be the District/Township name in Myanmar script, written in the local language. It may be an alternative representation of the "DT" field, showing the name of the district/township in Myanmar's native language.  |
| PCODE_V    | This could be a Version of the Postal Code or a verification value used internally in the dataset. In this case, the value is "9.4", possibly indicating a specific version of postal codes or an accuracy measure.                  |
| geometry   | This column represents the spatial data for each district/township. It contains the geometrical shape (MULTIPOLYGON) defining the boundaries of the state or district/township, with coordinates provided in longitude and latitude. |

# 3.0 Data Pre-processing

To ensure accuracy and usability of the data, several preprocessing steps will be undertaken for the different datasets.

## 3.1 Myanmar Shapefile

### 3.1.1 Setting the CRS for the

Since Myanmar uses CRS of 32647 and when we download the map it's in WGS84, we should change it to 32647 .

::: panel-tabset
## State

```{r}
st_crs(M_State_Sf)
# Set the CRS for m_sf, assuming the appropriate CRS is WGS 84 (EPSG:32647)
M_State_Sf <- st_transform(M_State_Sf, crs = 32647)
# Verify that the CRS has been correctly set
print(st_crs(M_State_Sf))
```

## District

```{r}
st_crs(M_District_Sf)
# Set the CRS for m_sf, assuming the appropriate CRS is WGS 84 (EPSG:32647)
M_District_Sf <- st_transform(M_District_Sf, crs = 32647)
# Verify that the CRS has been correctly set
print(st_crs(M_District_Sf))
```
:::

### 3.1.2 Renaming and removal of column names

::: panel-tabset
## State

```{r}
colnames(M_State_Sf) <- c("OBJECTID", "state","state_code","type", "state_myr", "mimi_version", "geometry")

M_State_Sf_Cleansed <- M_State_Sf %>% select(state, type, state_myr ,geometry)
```

## District

```{r}
colnames(M_District_Sf) <- c("OBJECTID", "state", "state_code", "district", "district_code", "district_mmr", "mimi_version", "geometry")

M_District_Sf_Cleansed <- M_District_Sf %>% select(state, district, district_mmr, geometry)

```
:::

### 3.1.3 Checking for validity of data

When working with spatial data, it’s crucial to ensure that all geometries are valid. Invalid geometries can cause errors in analysis and visualization.

1.  **Checking Validity with `st_is_valid()`**:

2.  **Identifying Invalid Geometries**:

3.  **Fixing Invalid Geometries with `st_make_valid()`**

::: panel-tabset
## State

```{r}
#checking if it's valid
M_State_Sf_Validity <- st_is_valid(M_State_Sf_Cleansed)
M_State_Sf_Invalid <- which(!M_State_Sf_Validity)
if (length(M_State_Sf_Invalid) > 0) {
  print("MPZ Invalid!")
  print(M_State_Sf_cleansed[M_State_Sf_Invalid, ])
} else {
  print("it's valid!")
}
```

## District

```{r}
#checking if it's valid
M_District_Sf_Validity <- st_is_valid(M_District_Sf_Cleansed)
M_District_Sf_Invalid <- which(!M_District_Sf_Validity)
if (length(M_District_Sf_Invalid) > 0) {
  print("MPZ Invalid!")
  print(M_District_Sf_cleansed[M_District_Sf_Invalid, ])
} else {
  print("it's valid!")
}
```
:::

### 3.1.4 Visualizing the mynamar map

On the top right, you can toggle between the district level and also the state level to understand more about the boundaries of Myanmar.

::: panel-tabset
## State

```{r, eval = TRUE, message = FALSE }
tmap_mode("plot")
tm_shape(M_State_Sf_Cleansed) +  # Base map (Myanmar boundaries)
  tm_polygons("state",  # Color the base map by state
              palette = "Set3",  # Use Set3 color palette for states
              border.col = "gray",  # Border color for the states
              alpha = 0.5,  # Semi-transparent polygons
              title = "State",  # Legend title for states
              legend.show = TRUE,  # Show legend for state colors
             ) +
  tm_layout(main.title = "States of Myanmar",  # Main map title
            legend.outside = TRUE)  # Position the legend outside the map
```

## District

There is more than 80 district here, so it only showcases 30 :)

```{r, eval = TRUE, message = FALSE }
tm_shape(M_District_Sf_Cleansed) +  # Base map (Myanmar boundaries)
  tm_polygons("district",  # Color the base map by district
              palette = "Set3",  # Use Set3 color palette for districts
              border.col = "gray",  # Border color for the districts
              alpha = 0.5,  # Semi-transparent polygons
              title = "District",  # Legend title for districts
              legend.show = TRUE,  # Show legend for district colors
              ) +
  tm_layout(main.title = "Districts of Myanmar",  # Main map title
            legend.outside = TRUE)  # Position the legend outside the map

```
:::

## 3.2 ACLED Data

### 3.2.1 Changing the Column Names

Since Myanmar's regional hierarchy follows **State**, **District**, and **Township** levels, we will rename the columns accordingly:

-   `admin1` → **State**

-   `admin2` → **District**

-   `admin3` → **Township**

This is important because different countries use different administrative hierarchies. For example, in Singapore, the hierarchy is organized by **Region** and **Subzones**. Adjusting these names ensures that our dataset aligns with Myanmar’s specific regional structure for accurate analysis.

```{r,  eval = TRUE}
ACLEDData_Cleanse <- ACLEDData %>%
  select(event_id_cnty, event_date, year, disorder_type, event_type, actor1, inter1, 
         actor2, inter2, interaction, admin1, admin2, admin3, location, latitude, 
         longitude, fatalities) %>%
  rename(state = admin1, district = admin2, township = admin3) %>%
  mutate(across(where(is.character), ~ replace_na(.x, "NA")),  # Replace NA in character columns with "NA"
         across(where(is.numeric), ~ replace_na(.x, 0)))  # Replace NA in numeric columns with 0
```

### 3.2.2 Adding a "Quarter-Year" Column

To facilitate our temporal analysis, we need to add a **"quarter-year"** column based on the `event_date` field. This can be done by adjusting the date format to represent the quarter and year, ensuring that each event is categorized by the specific quarter it occurred in (e.g., **Q1-2021**, **Q2-2022**). This will allow for easier analysis of conflict trends over time.

```{r}
# Convert event_date to Date format (if it's not already a date)
ACLEDData_Cleanse$event_date <- as.Date(ACLEDData_Cleanse$event_date, format="%d-%b-%y")  # Adjust the format if needed
# Add a new column that shows the quarter and year
ACLEDData_Cleanse <- ACLEDData_Cleanse %>%
  mutate(quarter_year = paste0("Q", quarter(event_date), "-", year(event_date)))

head(ACLEDData_Cleanse)

```

### 3.2.3 Joining ACLED's Codebook Description

ACLED's stores their data for the column "interaction" and "inter1" and "inter2" in codes, using their code book, let's reorganise their data for simplier view, we can reference the code book here to know what each code represent. Map it out as a csv file read it in and change accordingly.

#### 3.2.3.1 Left joining inter1 and inter's description.

For more details about [each inter code read here.](https://acleddata.com/knowledge-base/codebook/#actor-names-types-and-inter-codes)

```{r}
ACLEDActorInterCode <- read_csv("data/raw/aspatial/ActorTypesInterCode.csv")
ACLEDData_Cleanse <- ACLEDData_Cleanse %>%
  left_join(ACLEDActorInterCode, by = c("inter1" = "code")) %>%
  rename(inter1_description = Description)
# Left join again for inter2
ACLEDData_Cleanse <- ACLEDData_Cleanse %>%
  left_join(ACLEDActorInterCode, by = c("inter2" = "code")) %>%
  rename(inter2_description = Description)

datatable(head(ACLEDData_Cleanse, 5), options = list(pageLength = 5, autoWidth = TRUE))

```

#### 3.2.3.2 Left joining interaction description.

For more details about [each interaction code read here.](https://acleddata.com/knowledge-base/codebook/#interaction-codes)

```{r, eval = TRUE}
ACLEDInteractionCode <- read_csv("data/raw/aspatial/AcledInteractionCodes.csv")
ACLEDData_Cleanse <- ACLEDData_Cleanse %>%
  left_join(ACLEDInteractionCode, by = c("interaction" = "code")) %>%
  rename(interaction_description = Description)
head(ACLEDData_Cleanse)
```

### 3.2.3 Making it a SF Object and reverse geolocate state and district

Since ACLED provides longitude and latitude data, I prefer to reverse geolocate the points to match Myanmar's official state and district boundaries. We are uncertain how ACLED assigns these regions, so to ensure consistency, we remove the original state and district columns from the ACLED data and replace them with the geolocated values.

***Steps:***

1.  **Convert ACLED Data to an SF Object**: Using longitude and latitude coordinates, transform the ACLED dataset into a spatial object. Remember thatt we have to set CRS 32647 here as well.

2.  **Perform a Spatial Join**: Match the points from ACLED with the corresponding state and district boundaries from the `m_sf` shapefile, selecting only those columns.

3.  **Remove Original Columns**: After the spatial join, drop the original `state`, `district`, and `township` columns from the ACLED dataset.

4.  **Rename the Joined Columns**: Rename the newly joined `state.y` and `district.y` to `state` and `district`, effectively replacing the original columns with the reverse-geolocated values.

```{r}
# Step 1: Convert ACLEDDataCleanse to an sf object using longitude and latitude
ACLEDData_Cleanse_Sf <- st_as_sf(ACLEDData_Cleanse, coords = c("longitude", "latitude"), crs = 4326, remove = FALSE)

# Step 2: Transform ACLEDDataCleanse_sf to the same CRS as m_sf (EPSG: 32647)
ACLEDData_Cleanse_Sf <- st_transform(ACLEDData_Cleanse_Sf, crs = 32647)

# Step 3: Perform a spatial join, selecting only the state and district from m_sf
reverse_geolocated_state <- st_join(ACLEDData_Cleanse_Sf, M_State_Sf_Cleansed[, c("state")], join = st_intersects)

# Step 2: Spatial join to add 'district' from M_District_Sf_Cleansed
reverse_geolocated_district <- st_join(reverse_geolocated_state, M_District_Sf_Cleansed[, c("district")], join = st_intersects)

# Step 3: Remove original 'state', 'district', and 'township' columns from ACLEDData_Cleanse (if they exist)
# This step removes the original columns, and then renames the newly joined columns
ACLEDData_Cleanse_Sf <- reverse_geolocated_district %>%
  select(-contains("state.x"), -contains("district.x"), -contains("township")) %>%  # Remove old state, district, township columns
  rename(state = state.y, district = district.y)  # Rename newly joined columns

ACLEDData_Cleanse <- st_drop_geometry(ACLEDData_Cleanse_Sf)

# View the updated data
print(ACLEDData_Cleanse_Sf)
```

### 3.2.5 Visualizing it by Event Type

```{r}
# Set tmap mode to plot for static maps
tmap_mode("plot")
bbox <- st_bbox(M_State_Sf_Cleansed)  # Assuming you are using sf object

# Create the tmap object with the base map and event markers
tm_shape(M_State_Sf_Cleansed) + 
    tm_polygons("state", alpha = 0.3, border.col = "gray") +  # Base map with higher transparency
  
  # Add event markers (bubbles) with size based on fatalities
  tm_shape(ACLEDData_Cleanse_Sf) + 
  tm_bubbles(size = "fatalities",  # Marker size based on fatalities
             col = "event_type",  # Color markers by event type
             palette = "Set1",  # Use Set1 color palette for event types
             border.col = "black",  # Border color for bubbles
             border.alpha = 0.5,  # Semi-transparent border
             title.size = "Number of Fatalities",  # Title for bubble size legend
             title.col = "Event Types") +  # Title for event type legend
  
  # Layout settings for the map, including title and legend positioning
  tm_layout(main.title = "Myanmar's State Conflicts by Fatalities",  # Main map title
            main.title.size = 1.5,  # Title font size
            legend.outside = TRUE,  # Position legend outside the map
            legend.outside.size = 0.5,  # Adjust size of outside legend
            legend.position = c("left", "top"),  # Position for the event type legend
            legend.title.size = 1.2,  # Size of the legend title
            legend.text.size = 1,  # Size of the legend text
            legend.bg.color = "white",  # Background color for the legend
            legend.bg.alpha = 0.5,  # Transparency for the legend background
            inner.margins = c(0.05, 0.05, 0.05, 0.05)) 
  
```

# 4.0 Exploratory Data analysis

With the data cleansed, let's conduct a high-level analysis of our dataset to determine some key statistics.

The central question we're exploring is:

**"Which district in Myanmar has the highest number of conflicts that may be concerning to civilians?"**

In section 3.2.5, we recognized that Myanmar has many states and numerous conflicts during this period. Therefore, we will aggregate the data at the state level to prioritize states based on the following key figures:

-   **Civilian Involvement**: We focus on events where either Actor 1 or Actor 2 is a civilian, as these are likely to raise humanitarian concerns.

-   **Total Conflicts**: This measures the overall number of conflict events in each state, helping us identify which states experienced the most conflict.

-   **Conflict Density**: This calculates the number of conflicts per square kilometer in each state, allowing us to understand the intensity of conflicts relative to the size of the state.

-   **Total Fatalities**: This sums up the total number of fatalities within each state, highlighting areas with the highest death toll, which are likely experiencing the most severe impacts.

-   **Fatalities Density**: This measures the fatalities per square kilometer, giving a sense of how deadly the conflicts are in each state in relation to its area.

This analysis will allow us to focus on the states most affected by conflicts that pose the greatest risk to civilians.

## 4.1 Aggregation of Data for exploratory purposes

**Step 1: Filter Data for Civilians**

In this first step, the data (`ACLEDData_Cleanse`) is filtered so that only rows where either "Civilians" are involved in the conflict (`inter1_description` or `inter2_description`) are kept. Additionally, rows where the state information is missing (`NA`) are removed because these conflicts can't be assigned to a specific geographical area.

```{r}
filtered_data <- ACLEDData_Cleanse %>%
  filter((inter1_description == "Civilians" | inter2_description == "Civilians") & !is.na(state))
```

**Step 2: Calculate State Area in Square Kilometers**

Next, the code calculates the area for each state from the `M_State_Sf_Cleansed` spatial dataset. The `st_area` function retrieves the area in square meters, and dividing by 1 million (`1e6`) converts it into square kilometers. This information will be used later to calculate conflict and fatality density.

```{r}
state_area_km2 <- st_area(M_State_Sf_Cleansed) / 1e6
state_area_df <- data.frame(state = M_State_Sf_Cleansed$state, area_km2 = as.numeric(state_area_km2))
```

**Step 3: Aggregate Total Conflicts and Fatalities by State**

The next step is to group the filtered data by state and calculate two key metrics: the total number of conflicts and the total number of fatalities for each state. This is done using `group_by` and `summarise`.

```{r}
agg_data_by_state <- filtered_data %>%
  group_by(state) %>%
  summarise(
    total_conflicts = n(), 
    total_fatalities = sum(fatalities, na.rm = TRUE), 
    .groups = "drop"
  )
```

**Step 4: Convert to Non-Spatial Data Frame**

Here, the spatial data is converted into a regular data frame by dropping the geometry information. This allows easier manipulation of the non-spatial data for further processing.

```{r}
filtered_data_df <- st_drop_geometry(filtered_data)
```

**Step 5: Prepare Data Frame for Yearly Data**

To store yearly conflict and fatality data for each state, an empty data frame is initialized by selecting distinct states from the filtered data

```{r}
final_result <- filtered_data_df %>% select(state) %>% distinct()
```

**Step 6: Loop Through Each Year and Calculate Yearly Conflicts/Fatalities**

In this step, the code iterates over each unique year in the dataset. For each year, it calculates the total conflicts and fatalities for each state. The results are merged back into the `final_result` data frame, with columns named according to the year (e.g., `conflicts_2021`, `fatalities_2021`).

```{r}
unique_years <- unique(filtered_data_df$year)

for (yr in unique_years) {
  yearly_data <- filtered_data_df %>%
    filter(year == yr) %>%
    group_by(state) %>%
    summarise(
      conflicts = n(), 
      fatalities = sum(fatalities, na.rm = TRUE)
    ) %>%
    rename_at(vars(conflicts, fatalities), ~ paste0(., "_", yr))  # Rename with year
  
  final_result <- left_join(final_result, yearly_data, by = "state")
}

```

**Step 7: Replace NAs with 0**

Any missing data for a state-year combination (e.g., a state with no conflicts in a particular year) is replaced with 0 to avoid leaving gaps in the analysis.

```{r}
final_result <- final_result %>%
  mutate(across(everything(), ~ ifelse(is.na(.), 0, .)))
```

**Step 8: Calculate Conflict and Fatality Density**

Now, the code calculates the density of conflicts and fatalities per square kilometer for each state. The results from Step 3 (`agg_data_by_state`) are joined with the state area data from Step 2. The density is simply the number of conflicts or fatalities divided by the area in square kilometers.

```{r}
agg_data_with_density <- agg_data_by_state %>%
  left_join(state_area_df, by = "state") %>%
  mutate(
    conflict_density = total_conflicts / area_km2,
    fatality_density = total_fatalities / area_km2
  )
```

**Step 9: Merge Yearly Data and Density with Spatial Data**

Finally, the spatial data (`M_State_Sf_Cleansed`) is merged with the yearly conflict/fatality data (`final_result`) and the density data (`agg_data_with_density`). Additional calculations are made to find the fatality-per-conflict ratio which are then added to the final spatial dataset.

```{r}
finalized_map <- M_State_Sf_Cleansed %>%
  left_join(final_result, by = "state") %>%
  left_join(agg_data_with_density, by = "state")

finalized_map <- finalized_map %>%
  mutate(conflict_fatality_ratio = ifelse(total_fatalities == 0, NA, total_fatalities / total_conflicts))

finalized_map <- finalized_map %>%
  mutate(
    fatality_per_conflict = ifelse(total_conflicts == 0, NA, total_fatalities / total_conflicts),
  )

finalized_map <- finalized_map %>%
  mutate(
    rank_total_conflicts = rank(-total_conflicts, ties.method = "min"),  # Rank total_conflicts (largest to smallest)
    rank_total_fatalities = rank(-total_fatalities, ties.method = "min"),  # Rank total_fatalities (largest to smallest)
    rank_conflict_density = rank(-conflict_density, ties.method = "min"),  # Rank conflict_density (largest to smallest)
    rank_fatality_density = rank(-fatality_density, ties.method = "min"),  # Rank fatality_density (largest to smallest)
    rank_fatality_per_conflict = rank(-fatality_per_conflict, ties.method = "min")  # Rank fatality_per_conflict (largest to smallest)
  )

```

**Final Output: Display the Data**

The `finalized_map` contains all the processed information, including conflict/fatality counts, densities, and state geometry, which can now be visualized or further analyzed.

```{r}
head(finalized_map)
```

### 4.2 Visualizing the aggregated data.

For each column that we created earlier, we can now showcase it in a choropleth map to highlight the states with the highest values in each category. These maps will help visually identify which state has the highest value for each column. You can navigate through the tabset to explore the different metrics and easily view the data on a map!

::: panel-tabset
## Total Civilian Conflicts

```{r}
# Create the tmap object for total civilian conflicts
tm_total_conflicts <- tm_basemap(server = c("Esri.WorldGrayCanvas", "OpenStreetMap", "Esri.WorldTopoMap")) +
  # Layer for total civilian conflicts
  tm_shape(finalized_map) +
  tm_polygons("total_conflicts", 
              title = "Total Civilian Conflicts",
              palette = "Reds", 
              border.col = "black", 
              alpha = 0.8,  # Transparency for polygons
              border.alpha = 0.5,  # Semi-transparent border
              id = "state") +  # Set state as identifier for the polygons

  # Layout settings matching your style
  tm_layout(
    main.title = "Myanmar's State by Total Civilian Related Conflicts",  # Main map title
    main.title.size = 1.5,  # Title font size
    legend.outside = TRUE,  # Position legend outside the map
    legend.outside.size = 0.5,  # Adjust size of outside legend
    legend.position = c("left", "top"),  # Position for the event type legend
    legend.title.size = 1.2,  # Size of the legend title
    legend.text.size = 1,  # Size of the legend text
    legend.bg.color = "white",  # Background color for the legend
    legend.bg.alpha = 0.5,  # Transparency for the legend background
    inner.margins = c(0.05, 0.05, 0.05, 0.05)  # Set inner margins for better spacing
  )
tm_total_conflicts
```

## Total Fatalities for civilians related conflicts.

```{r}
# Create the tmap object for total civilian conflicts
tm_total_fatalities <- tm_basemap(server = c("Esri.WorldGrayCanvas", "OpenStreetMap", "Esri.WorldTopoMap")) +
  # Layer for total civilian conflicts
  tm_shape(finalized_map) +
  tm_polygons("total_fatalities", 
              title = "Total Fatalities by Civilian Related Conflicts",
              palette = "Blues", 
              border.col = "black", 
              alpha = 0.8,  # Transparency for polygons
              border.alpha = 0.5,  # Semi-transparent border
              id = "state") +  # Set state as identifier for the polygons

  # Layout settings matching your style
  tm_layout(
    main.title = "Myanmar's State by Total Fatatlies For Civilian Related Conflicts",  # Main map title
    main.title.size = 1.0,  # Title font size
    legend.outside = TRUE,  # Position legend outside the map
    legend.outside.size = 0.5,  # Adjust size of outside legend
    legend.position = c("left", "top"),  # Position for the event type legend
    legend.title.size = 1.2,  # Size of the legend title
    legend.text.size = 1,  # Size of the legend text
    legend.bg.color = "white",  # Background color for the legend
    legend.bg.alpha = 0.5,  # Transparency for the legend background
    inner.margins = c(0.05, 0.05, 0.05, 0.05)  # Set inner margins for better spacing
  )

tm_total_fatalities
```

## Civilian Conflict Density

```{r}
tm_conflict_density <- tm_basemap(server = c("Esri.WorldGrayCanvas", "OpenStreetMap", "Esri.WorldTopoMap")) +
  # Layer for total civilian conflicts
  tm_shape(finalized_map) +
  tm_polygons("conflict_density", 
              title = "Myanmar State by Civilian Related Conflicts Density",
              palette = "Blues", 
              border.col = "black", 
              alpha = 0.8,  # Transparency for polygons
              border.alpha = 0.5,  # Semi-transparent border
              id = "state") +  # Set state as identifier for the polygons

  # Layout settings matching your style
  tm_layout(
    main.title = "Myanmar State by Civilian Related Conflicts Density",  # Main map title
    main.title.size = 1.0,  # Title font size
    legend.outside = TRUE,  # Position legend outside the map
    legend.outside.size = 0.5,  # Adjust size of outside legend
    legend.position = c("left", "top"),  # Position for the event type legend
    legend.title.size = 1.2,  # Size of the legend title
    legend.text.size = 1,  # Size of the legend text
    legend.bg.color = "white",  # Background color for the legend
    legend.bg.alpha = 0.5,  # Transparency for the legend background
    inner.margins = c(0.05, 0.05, 0.05, 0.05)  # Set inner margins for better spacing
  )

tm_conflict_density
```

## Fatality Density

```{r}
tm_fatalities_conflict <- tm_basemap(server = c("Esri.WorldGrayCanvas", "OpenStreetMap", "Esri.WorldTopoMap")) +
  # Layer for total civilian conflicts
  tm_shape(finalized_map) +
  tm_polygons("fatality_density", 
              title = "Myanmar State by Fatalies For Civilians Related Conflicts Density Per Km^2",
              palette = "Blues", 
              border.col = "black", 
              alpha = 0.8,  # Transparency for polygons
              border.alpha = 0.5,  # Semi-transparent border
              id = "state") +  # Set state as identifier for the polygons

  # Layout settings matching your style
  tm_layout(
    main.title = "Myanmar State by Fatalies For Civilians Related Conflicts Density Per Km^2",  # Main map title
    main.title.size = 1.0,  # Title font size
    legend.outside = TRUE,  # Position legend outside the map
    legend.outside.size = 0.5,  # Adjust size of outside legend
    legend.position = c("left", "top"),  # Position for the event type legend
    legend.title.size = 1.0,  # Size of the legend title
    legend.text.size = 0.8,  # Size of the legend text
    legend.bg.color = "white",  # Background color for the legend
    legend.bg.alpha = 0.5,  # Transparency for the legend background
    inner.margins = c(0.05, 0.05, 0.05, 0.05)  # Set inner margins for better spacing
  )

tm_fatalities_conflict
```

## Fatality Per Civilian Conflict

```{r}
tm_fatalities_density <- tm_basemap(server = c("Esri.WorldGrayCanvas", "OpenStreetMap", "Esri.WorldTopoMap")) +
  # Layer for total civilian conflicts
  tm_shape(finalized_map) +
  tm_polygons("fatality_per_conflict", 
              title = "Myanmar State by Fatalies for Civilian Related Conflicts",
              palette = "Blues", 
              border.col = "black", 
              alpha = 0.8,  # Transparency for polygons
              border.alpha = 0.5,  # Semi-transparent border
              id = "state") +  # Set state as identifier for the polygons

  # Layout settings matching your style
  tm_layout(
    main.title = "Myanmar State by Fatalies for Civilian Related Conflicts",  # Main map title
    main.title.size = 1.0,  # Title font size
    legend.outside = TRUE,  # Position legend outside the map
    legend.outside.size = 0.5,  # Adjust size of outside legend
    legend.position = c("left", "top"),  # Position for the event type legend
    legend.title.size = 1.0,  # Size of the legend title
    legend.text.size = 0.8,  # Size of the legend text
    legend.bg.color = "white",  # Background color for the legend
    legend.bg.alpha = 0.5,  # Transparency for the legend background
    inner.margins = c(0.05, 0.05, 0.05, 0.05)  # Set inner margins for better spacing
  )

tm_fatalities_density
```
:::

## 4.3 Analysis on the aggregated data to find top 3 state to analyse

### 4.3.1 Choose which States to analyse?

With the maps above, everyone can choose what they would like to analyze, whether it’s total civilian conflicts or fatalities by state. However, I would like to focus on the central question:

**Which state has the highest amount of conflict and fatality density?**

By using density, I’ve aimed to assess fatalities in relation to conflicts and ensure a fair comparison by adjusting for density.

::: callout-note
Keep in mind, this is not the most precise analysis, as other factors—such as ethnicity, population demographics, and gender—could also be considered. However, for the purpose of this study, I have chosen to focus on solely on the state's conflict and fatality density.
:::

**Conflict Density**: This is the number of conflicts per square kilometer in a state.

1.  Conflict Density=Total ConflictsArea of State (km²)\text{Conflict Density} = \frac{\text{Total Conflicts}}{\text{Area of State (km²)}}Conflict Density=Area of State (km²)Total Conflicts​

    This tells you how many conflicts occur per unit of area (1 km²) in each state.

2.  **Fatality Density**: This is the number of fatalities per square kilometer.

    Fatality Density=Total FatalitiesArea of State (km²)\text{Fatality Density} = \frac{\text{Total Fatalities}}{\text{Area of State (km²)}}Fatality Density=Area of State (km²)Total Fatalities​

### 4.3.2 Viewing the top 3 states across

Using the map below, you can interactively explore the Conflict and Fatality Density. We observe that the top three states are as follows, and here’s how they compare across the data set.

You can use the layer toggle to switch between fatalities and conflicts, or click on the map layers to view detailed, aggregated data for each state.

```{r}
# Step 1: Set tmap mode to view for interactive maps
tmap_mode("view")

# Step 2: Define popup variables to show all relevant columns when clicking on a state
popup_variables <- c( 
                     "Total Civilian Conflicts" = "total_conflicts",
                     "Fatalities" = "total_fatalities",
                     "Civilian Conflict Density" = "conflict_density",
                     "Fatality Density" = "fatality_density",
                     "Fatality Per Civilian Conflict" = "fatality_per_conflict",
                     "Ranked For Total Conflict By State (Out of 15)" = "rank_total_conflicts",
                     "Ranked For Total Fatalities By State (Out of 15)" = "rank_total_fatalities",
                     "Ranked For Conflict Density By State (Out of 15)" = "rank_conflict_density",
                     "Ranked For Fatalities Density By State (Out of 15)" = "rank_fatality_density",
                     "Ranked For Fatalies/Conflict By State (Out of 15)" = "rank_fatality_per_conflict"
                     )

# Step 3: Create the map with 6 layers for toggling
tm <- tm_basemap(server = c("Esri.WorldGrayCanvas", "OpenStreetMap", "Esri.WorldTopoMap")) +
  tm_shape(finalized_map) +
  tm_polygons("conflict_density", 
              title = "Civilian Conflict Density",
              palette = "Oranges", 
              border.col = "black",
              popup.vars = popup_variables,
              id = "state", 
              group = "Civilian Conflict Density") +
  tm_shape(finalized_map) +
  tm_polygons("fatality_density", 
              title = "Fatality Density",
              palette = "Purples", 
              border.col = "black",
              popup.vars = popup_variables,
              id = "state", 
              group = "Fatality Density") +
  tm_layout(
    legend.outside = TRUE,
    legend.outside.size = 0.5,  # Adjust the size of the legend
    legend.position = c("left", "top")  # Position the legend
  )
# Step 5: Display the interactive map
tm
tmap_mode("plot")

```

```{r}
finalized_data_df <- as.data.frame(st_drop_geometry(finalized_map))
# Sort the data by conflict_density and fatality_density in descending order
finalized_data_df <- finalized_data_df %>%
  arrange(desc(conflict_density), desc(fatality_density))

# Format the densities to show "per km²"
finalized_data_df$conflict_density_label <- paste0(round(finalized_data_df$conflict_density, 2), " per km²")
finalized_data_df$fatality_density_label <- paste0(round(finalized_data_df$fatality_density, 2), " per km²")

# Create bar chart for Conflict Density (sorted by conflict_density)
conflict_density_plot <- ggplot(finalized_data_df, aes(x = reorder(state, -conflict_density), y = conflict_density)) +
  geom_bar(stat = "identity", fill = "orange") +
  geom_text(aes(label = conflict_density_label), vjust = 1.8, size = 1.5, color = "black", position = position_stack(vjust = 0.5)) +  # Place text at bottom of bar
  ggtitle("Top States by Conflict Density (per km²)") +
  xlab("State") +
  ylab("Conflict Density (per km²)") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Create bar chart for Fatality Density (sorted by fatality_density)
fatality_density_plot <- ggplot(finalized_data_df, aes(x = reorder(state, -fatality_density), y = fatality_density)) +
  geom_bar(stat = "identity", fill = "purple") +
  geom_text(aes(label = fatality_density_label), vjust = 1.8, size = 1.5, color = "black", position = position_stack(vjust = 0.5)) +  # Place text at bottom of bar
  ggtitle("Top States by Fatality Density (per km²)") +
  xlab("State") +
  ylab("Fatality Density (per km²)") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Display both charts side by side
grid.arrange(conflict_density_plot, fatality_density_plot, ncol = 2)
```

### **4.3.3 Top 3 Chosen state for further analysis**

#### 4.3.3.1 Yangon

#### ![](images/clipboard-1120231091.png)

**Yangon**, Myanmar’s largest city and former capital, remains the country’s **economic and cultural hub**. Although it is no longer the political capital, Yangon holds the highest population density in the country, making it a vital urban center with significant influence.

According to the data, **Yangon ranks 5th** for total conflicts, with **1,489 civilian conflicts** reported, and **8th in fatalities**, with **431 deaths**. However, it stands out with the **highest civilian conflict density (0.0531)** and **fatality density (0.01536)** among Myanmar’s 15 states. This means that while the overall number of conflicts may not be the highest, they are **more concentrated** within Yangon’s urban area, resulting in the **highest per-unit area conflict rate**.

Yangon's **urbanization** and strategic **economic importance** likely make it a hotspot for civilian unrest. Social tensions in a densely populated city lead to frequent conflicts, reflected in its **rank of 1st for conflict density and fatality density**. Despite fewer total conflicts compared to other states, Yangon’s density of unrest highlights its vulnerability to civil tensions.

#### 4.3.3.2 Mandalay

![](images/clipboard-255608195.png)

Mandalay, the second-largest city in Myanmar, is known for its cultural significance and central location in the country. It holds a key strategic position in the economy and transportation networks, making it vulnerable to unrest.

The data shows **Mandalay ranks 2nd** for total civilian conflicts with **2,021 conflicts** and **950 fatalities**. Its **civilian conflict density** is **0.0255**, placing it **3rd** in density, while its **fatality density** is **0.0120**, ranked **2nd**. Despite being second in conflict counts, the concentration of conflicts and fatalities suggests that civil unrest is deeply rooted in the region, but not as dense as in Yangon.

Mandalay's high fatality-to-conflict ratio (**0.4701 fatalities per conflict**) highlights the deadly nature of conflicts, ranking **7th** in fatalities per conflict. This reflects a region where conflicts, though frequent, lead to significant loss of life compared to other states.

#### 4.3.3.3 Sagaling.

![](images/clipboard-3297902840.png)

Sagaing, located in northern Myanmar, is one of the country’s most conflict-ridden regions, often affected by armed insurgencies and ethnic clashes due to its proximity to volatile borders.

The data reveals that **Sagaing ranks 1st** in total civilian conflicts with **5,346 conflicts** and **3,319 fatalities**, giving it the highest fatality count as well. However, its **civilian conflict density** is **0.0241** (ranked **3rd**) and its **fatality density** is **0.01497** (ranked **3rd**), indicating a widespread yet slightly less concentrated conflict zone compared to Yangon and Mandalay.

Sagaing’s **fatality per civilian conflict** ratio of **0.6208** ranks **2nd**, emphasizing the high lethality of conflicts in the region. With both the largest number of conflicts and a high fatality rate, Sagaing represents one of the most dangerous and unstable areas in Myanmar for civilians/

## 4.4 Final Round of Cleansing ACLED Data

In this final stage of the data cleansing process, we focus on preparing the **ACLED (Armed Conflict Location & Event Data)** for the different states. The key steps include:

1.  **Filtering**: We first filter the dataset to focus on data specific to **Yangon**.

2.  **Converting to Spatial Format**: Using the `st_as_sf()` function, we transform the filtered data into a **simple features (sf)** object, a format commonly used for spatial data in R. This involves specifying **longitude** and **latitude** as the coordinates and setting the correct **WGS84 (CRS 4326)** coordinate system for global geographic data.

3.  **Coordinate System Transformation**: We apply the `st_transform()` function to project the spatial data from **WGS84 (CRS 4326)** to **UTM Zone 47N (CRS 32647)**, which is more appropriate for spatial analysis in Myanmar. This step ensures accurate distance and area calculations.

4.  **Validity Check**: Using `st_is_valid()`, we validate the geometries in the spatial data to ensure there are no invalid shapes, such as self-intersecting polygons, which could cause errors during analysis.

5.  **Conversion to Spatial Data Frame**: Finally, we convert the **sf** object into a **Spatial Data Frame** (`as_Spatial()`) for compatibility with specific spatial analysis functions that require this format.

This process ensures that the **States** data is accurately represented in a geospatial format, with proper **coordinate transformation** and **validity checks** applied. It prepares the data for further geospatial operations, such as mapping and spatial pattern analysis, with the confidence that the dataset is clean and valid for use.

::: panel-tabset
## Yangon

```{r}
# Filter data for Yangon state from the entire ACLED dataset
Yangon_ACLED_Data <- filtered_data %>% 
  filter(state %in% c("Yangon"))

# Check the class of the data to confirm it's a dataframe
class(Yangon_ACLED_Data)

# Convert the filtered data into a spatial format (simple features object)
# Use longitude and latitude columns as coordinates, with WGS84 (CRS 4326) as the coordinate system
Yangon_ACLED_Data_Sf <- st_as_sf(Yangon_ACLED_Data, coords = c("longitude", "latitude"), crs = 4326, remove = FALSE)

# Transform the coordinate system to UTM Zone 47N (CRS 32647) for better spatial precision in Myanmar
Yangon_ACLED_Data_Sf <- st_transform(Yangon_ACLED_Data_Sf, crs = 32647)

# Check the class of the spatial object to confirm conversion
class(Yangon_ACLED_Data_Sf)

# Validate the spatial object to ensure all geometries are valid (no broken or self-intersecting geometries)
Yangon_ACLED_Validity <- st_is_valid(Yangon_ACLED_Data_Sf)

# Identify any invalid geometries and print them if they exist
Yangon_invalid <- which(!Yangon_ACLED_Validity)
if (length(Yangon_invalid) > 0) {
  print("Yangon is Invalid!")
  print(Yangon_ACLED_Data_Sf[Yangon_invalid, ])
} else {
  print("Yangon_ACLED_Data_Sf is valid!")
}

# Convert the sf object into a Spatial Data Frame (for compatibility with certain spatial analysis functions)
Yangon_ACLED_SFDF <- as_Spatial(Yangon_ACLED_Data_Sf)

# Final output - Yangon ACLED data in spatial data frame format, ready for analysis
Yangon_ACLED_SFDF
```

## Mandalay

```{r}
# Filter data for Mandalay state from the entire ACLED dataset
Mandalay_ACLED_Data <- filtered_data %>% 
  filter(state %in% c("Mandalay"))
# Check the class of the filtered data to confirm it's still a dataframe
class(Mandalay_ACLED_Data)

# Convert the filtered data into a spatial format (simple features object)
# Longitude and latitude are used as coordinates, and WGS84 (CRS 4326) is set as the coordinate system
Mandalay_ACLED_Data_Sf <- st_as_sf(Mandalay_ACLED_Data, coords = c("longitude", "latitude"), crs = 4326, remove = FALSE)

# Transform the coordinate system to UTM Zone 47N (CRS 32647) for better accuracy in the Myanmar region
Mandalay_ACLED_Data_Sf <- st_transform(Mandalay_ACLED_Data_Sf, crs = 32647)

# Verify that the data has been successfully converted into a spatial object
class(Mandalay_ACLED_Data_Sf)

# Validate the spatial data to check for any invalid geometries (e.g., self-intersections, broken polygons)
Mandalay_ACLED_Validity <- st_is_valid(Mandalay_ACLED_Data_Sf)

# Identify any invalid geometries and print them for inspection, if found
Mandalay_invalid <- which(!Mandalay_ACLED_Validity)
if (length(Mandalay_invalid) > 0) {
  print("Mandalay is Invalid!")
  print(Mandalay_ACLED_Data_Sf[Mandalay_invalid, ])
} else {
  # If all geometries are valid, print confirmation
  print("Mandalay_ACLED_Data_Sf is valid!")
}

# Convert the simple features object to a Spatial Data Frame for compatibility with spatial functions
Mandalay_ACLED_SFDF <- as_Spatial(Mandalay_ACLED_Data_Sf)

# Final output - Mandalay ACLED data in spatial data frame format, ready for analysis
Mandalay_ACLED_SFDF
```

## Sagaing

```{r}
Sagaing_ACLED_Data <- filtered_data %>% 
  filter(state %in% c("Sagaing"))

# Check the class of the filtered data to confirm it's still a dataframe
class(Sagaing_ACLED_Data)

# Convert the filtered data into a spatial format (simple features object)
# Longitude and latitude are used as coordinates, and WGS84 (CRS 4326) is set as the coordinate system
Sagaing_ACLED_Data_Sf <- st_as_sf(Sagaing_ACLED_Data, coords = c("longitude", "latitude"), crs = 4326, remove = FALSE)

# Transform the coordinate system to UTM Zone 47N (CRS 32647) for better accuracy in the Myanmar region
Sagaing_ACLED_Data_Sf <- st_transform(Sagaing_ACLED_Data_Sf, crs = 32647)

# Verify that the data has been successfully converted into a spatial object
class(Sagaing_ACLED_Data_Sf)

# Validate the spatial data to check for any invalid geometries (e.g., self-intersections, broken polygons)
Sagaing_ACLED_Validity <- st_is_valid(Sagaing_ACLED_Data_Sf)

# Identify any invalid geometries and print them for inspection, if found
Sagaing_invalid <- which(!Sagaing_ACLED_Validity)
if (length(Sagaing_invalid) > 0) {
  print("Sagaing is Invalid!")
  print(Sagaing_ACLED_Data_Sf[Sagaing_invalid, ])
} else {
  # If all geometries are valid, print confirmation
  print("Sagaing_ACLED_Data_Sf is valid!")
}

# Convert the simple features object to a Spatial Data Frame for compatibility with spatial functions
Sagaing_ACLED_SFDF <- as_Spatial(Sagaing_ACLED_Data_Sf)

# Final output - Sagaing ACLED data in spatial data frame format, ready for analysis
Sagaing_ACLED_SFDF


```
:::

# 5.0 Spatial Data Wrangling

Spatial data wrangling is a crucial step in preparing the dataset for **spatial point pattern analysis**. This section involves setting up the spatial boundaries for each state and transforming the data into appropriate formats for analysis. The goal is to define the area within which the point patterns (conflict events) will be analyzed and ensure that the data is in the correct format for further spatial operations.

## 5.1 Setting up the Owin Window for States.

In this step, we are setting up an **owin** object for each state using the **spatstat** package. An **owin** object defines the **spatial window**—or the boundary—within which our point pattern analysis will take place. Essentially, this window will encapsulate the polygonal boundary of each state, allowing us to focus on conflict data within those precise boundaries.

To create the **owin** object, we will:

-   Extract the polygon boundaries for each state from the spatial data.

-   Convert these boundaries into an **owin** object using the `as.owin()` function.

-   These spatial windows will ensure that all spatial operations, such as density estimation and pattern analysis, occur strictly within the boundaries of the specified state (e.g., **Yangon**, **Mandalay**, **Sagaing**).

This setup is crucial for ensuring that our spatial analysis focuses only on relevant geographic areas and doesn't incorporate any points outside the boundaries.

::: panel-tabset
## Yangon

```{r}
Yangon_Sf <- M_State_Sf %>% 
  filter(state %in% c("Yangon"))
# Step 1: Extract the individual polygons from the multipolygon
yangon_polygons <- st_cast(Yangon_Sf$geometry, "POLYGON")
yangon_polygons_filtered <- yangon_polygons[-c(1, 2)]
yangon_multipolygon_filtered <- st_combine(yangon_polygons_filtered)
# Add the filtered multipolygon back to the Yangon_Sf object
Yangon_Sf$geometry <- yangon_multipolygon_filtered
Yangon <- as_Spatial(Yangon_Sf)
Yangon_Owin <- as.owin(Yangon_Sf)
plot(Yangon_Owin)
summary(Yangon_Owin)
st_is_valid(Yangon_Sf)

```

## Mandalay

```{r}
# Filter the dataset to only include data for Mandalay state
Mandalay_Sf <- M_State_Sf %>% 
  filter(state %in% c("Mandalay"))
# Convert the Mandalay spatial dataframe into a Spatial Data Frame for further spatial operations
Mandalay <- as_Spatial(Mandalay_Sf)

# Convert the Mandalay spatial dataframe into an owin object for spatial point pattern analysis
Mandalay_Owin <- as.owin(Mandalay_Sf)

# Plot the owin object to visualize the boundaries of Mandalay
plot(Mandalay_Owin)

# Provide a summary of the owin object, showing its properties like dimensions and bounding box
summary(Mandalay_Owin)


```

## Sagaing

```{r}
# Filter the dataset to only include data for Sagaing state
Sagaing_Sf <- M_State_Sf %>% 
  filter(state %in% c("Sagaing"))

# Convert the Sagaing spatial dataframe into a Spatial Data Frame for further spatial operations
Sagaing <- as_Spatial(Sagaing_Sf)

# Convert the Sagaing spatial dataframe into an owin object for spatial point pattern analysis
Sagaing_Owin <- as.owin(Sagaing_Sf)

# Plot the owin object to visualize the boundaries of Sagaing
plot(Sagaing_Owin)

# Provide a summary of the owin object, showing its properties like dimensions and bounding box
summary(Sagaing_Owin)

```
:::

## 5.2 Setting up the ACLED Spatial Class

After defining the **owin** window for each state, we need to convert the conflict data into a suitable **spatial point pattern** object (typically using **spatstat's ppp** class). This class is essential for performing spatial point pattern analysis, as it links the geographic coordinates of conflict events to the state boundary.

Here’s what we’ll do:

-   We will first ensure that the conflict data is transformed into the appropriate spatial projection (UTM or other applicable projections).

-   The conflict data points will be linked to the **owin** window to define where these events occur within the state's boundary.

-   The result will be a **ppp** (point pattern) object, which is necessary for conducting spatial operations like **density estimation**, **K-function analysis**, or **G-function analysis**.

This step transforms our dataset into a fully spatially aware format, ready for statistical analysis.

::: panel-tabset
## Yangon

```{r}
# Extract the coordinates (longitude, latitude) from the Yangon spatial object
Yangon_ACLED_coords <- st_coordinates(Yangon_ACLED_Data_Sf)

# Define the bounding box (xmin, xmax, ymin, ymax) for Yangon, which sets the spatial extent of the window
Yangon_ACLED_bbox <- st_bbox(Yangon_ACLED_Data_Sf)

# Create the spatial window (owin object) for Yangon using the bounding box ranges
Yangon_ACLED_window <- owin(xrange = Yangon_ACLED_bbox[c("xmin", "xmax")], yrange = Yangon_ACLED_bbox[c("ymin", "ymax")])

# Create a ppp (point pattern) object for Yangon using the extracted coordinates and the defined window
Yangon_ACLED_ppp <- ppp(x = Yangon_ACLED_coords[, 1], y = Yangon_ACLED_coords[, 2], window = Yangon_ACLED_window)

# Check the summary of the ppp object to verify the number of points, window dimensions, and other properties
summary(Yangon_ACLED_ppp)

# Plot the ppp object to visually inspect the spatial distribution of conflict points in Yangon
plot(Yangon_ACLED_ppp)


```

## Mandalay

```{r}
# Extract the coordinates (longitude, latitude) from the Mandalay spatial object
Mandalay_ACLED_coords <- st_coordinates(Mandalay_ACLED_Data_Sf)

# Define the bounding box (xmin, xmax, ymin, ymax) for Mandalay, which sets the spatial extent of the window
Mandalay_ACLED_bbox <- st_bbox(Mandalay_ACLED_Data_Sf)

# Create the spatial window (owin object) for Mandalay using the bounding box ranges
Mandalay_ACLED_window <- owin(xrange = Mandalay_ACLED_bbox[c("xmin", "xmax")], yrange = Mandalay_ACLED_bbox[c("ymin", "ymax")])

# Create a ppp (point pattern) object for Mandalay using the extracted coordinates and the defined window
Mandalay_ACLED_ppp <- ppp(x = Mandalay_ACLED_coords[, 1], y = Mandalay_ACLED_coords[, 2], window = Mandalay_ACLED_window)

# Check the summary of the ppp object to verify the number of points, window dimensions, and other properties
summary(Mandalay_ACLED_ppp)

# Plot the ppp object to visually inspect the spatial distribution of conflict points in Mandalay
plot(Mandalay_ACLED_ppp)

```

## Sagaing

```{r}
# Extract the coordinates (longitude, latitude) from the Sagaing spatial object
Sagaing_ACLED_coords <- st_coordinates(Sagaing_ACLED_Data_Sf)

# Define the bounding box (xmin, xmax, ymin, ymax) for Sagaing, which sets the spatial extent of the window
Sagaing_ACLED_bbox <- st_bbox(Sagaing_ACLED_Data_Sf)

# Create the spatial window (owin object) for Sagaing using the bounding box ranges
Sagaing_ACLED_window <- owin(xrange = Sagaing_ACLED_bbox[c("xmin", "xmax")], yrange = Sagaing_ACLED_bbox[c("ymin", "ymax")])

# Create a ppp (point pattern) object for Sagaing using the extracted coordinates and the defined window
Sagaing_ACLED_ppp <- ppp(x = Sagaing_ACLED_coords[, 1], y = Sagaing_ACLED_coords[, 2], window = Sagaing_ACLED_window)
Sagaing_ACLED_ppp <- rescale(Sagaing_ACLED_ppp, 1000, "km")

# Check the summary of the ppp object to verify the number of points, window dimensions, and other properties
summary(Sagaing_ACLED_ppp)

# Plot the ppp object to visually inspect the spatial distribution of conflict points in Sagaing
plot(Sagaing_ACLED_ppp)

```
:::

::: callout-note
**Why dont you jitter, delete or mark any conflicts?**

The reason I did not apply jittering, deletion, or marking of the **conflicts** at this stage is that all the conflicts are **unique** and occurred across different **time zones**. Since there is no overlap in terms of exact location or time, it makes no sense to modify the data at this point. We will consider **jittering** later if we find that events are clustered too closely together in space, but for now, each conflict is distinct, and no adjustments are necessary.
:::

## 5.3 Combining them both

Finally, we will merge the **owin** object (state boundary) and the **spatial point pattern** data (conflict events) into a single object. This combination ensures that:

-   The spatial window constrains the analysis, focusing on the area within each state's boundary.

-   All conflict events are accurately represented within the confines of the defined boundary.

This step allows for **robust spatial point pattern analysis**, ensuring that both the boundaries and events are properly accounted for. With this merged object, we can perform advanced geospatial techniques, such as analyzing the distribution of conflict events, identifying hotspots, and calculating density functions within the state.

::: panel-tabset
## Yangon

```{r}
Yangon_ACLED_ppp = Yangon_ACLED_ppp[Yangon_Owin]
plot(Yangon_ACLED_ppp)
```

## Mandalay

```{r}
Mandalay_ACLED_ppp = Mandalay_ACLED_ppp[Mandalay_Owin]
plot(Mandalay_ACLED_ppp)
```

## Sagaing

```{r}
Mandalay_ACLED_ppp = Mandalay_ACLED_ppp[Mandalay_Owin]
plot(Mandalay_ACLED_ppp)
```
:::

# 6.0 Summary of Data sets Prepared

## 6. Summary of Data sets

We have created several distinct datasets, each serving a specific role in our spatial analysis of conflict events in Myanmar. Here’s a summary of each dataset, including the type of data they represent and a brief description of their purpose:

1.  **`M_State_SF` (sf object)**

    -   **Type**: Simple feature object (sf)

    -   **Description**: This is the cleaned and formatted dataset containing conflict events from ACLED (Armed Conflict Location & Event Data). It includes attributes like **location**, **event type**, and **time period**. This dataset serves as the foundation for further spatial analysis.

2.  **`{State}_SF` (sf object)**

    -   **Type**: Simple feature object (sf)

    -   **Description**: This dataset represents the **Myanmar boundary** and is used as the base map for the analysis. It defines the spatial extent and provides a reference layer for plotting conflict events within the country.

3.  **`Finalized_map` (aggregated data)**

    -   **Type**: Aggregated dataset

    -   **Description**: This dataset contains aggregated data for different **event types**, **quarters**, or other relevant categories. It is primarily used for **exploratory analysis** to get an overview of trends and patterns before performing detailed spatial point pattern analysis.

4.  **`filtered_data` (filtered ACLED data)**

    -   **Type**: Filtered dataset

    -   **Description**: This dataset consists of ACLED data filtered specifically for **civilian-related conflicts**. It focuses on events where civilians are involved, either in **inter 1** or **inter 2**, and is the primary dataset for analyzing civilian conflict events.

5.  **`{State}_ACLED_Data_Sf` (sf object)**

    -   **Type**: Simple feature object (sf)

    -   **Description**: These datasets (e.g., **Yangon_ACLED_Data_Sf**, **Mandalay_ACLED_Data_Sf**) are state-specific **ACLED data** stored as sf objects. They contain conflict data for individual states and will be used to analyze conflict patterns within each state’s boundary.

6.  **`{State}_ACLED_ppp` (ppp object)**

    -   **Type**: Planar point pattern object (ppp)

    -   **Description**: These are **point pattern datasets** created from the state-specific ACLED data (e.g., **Yangon_ACLED_ppp**, **Mandalay_ACLED_ppp**). They store the coordinates of conflict events and are used for in-depth spatial analyses, such as **density estimation** and **clustering**. If needed, jittering is applied to handle close events.

7.  **`{State}_Owin`(owin object)**

    -   **Type**: Spatial window object (owin)

    -   **Description**: These objects represent the **spatial boundary** of each state (e.g., **Yangon_Owin**, **Mandalay_Owin**). The **owin** window defines the geographic limits for the spatial point pattern analysis, ensuring that all conflict events are analyzed within the correct state boundary.

# 7.0 Deriving the Quarterly Kernel Density Estimation Layers

Kernel Density Estimation (KDE) is a key technique for spatial analysis, allowing us to estimate the probability density of events occurring in space. By applying KDE across different **quarters** for each state (Yangon, Mandalay, and Sagaing), we can visualize how the intensity of conflict events evolves over time. This will give us insights into **hotspots** and help track the spread or concentration of conflicts across Myanmar. Our analysis will focus on generating KDE layers for each quarter, comparing them, and identifying significant patterns.

## 7.1 Setting up a function to create quarterly for each state

We will create a function that takes the conflict data for each state and computes the **quarterly KDE**. This function will:

-   Filter the conflict events by **quarter**.

-   Apply the **KDE** to estimate the spatial density of events for that quarter.

-   Return a KDE layer that can be used for visualization and analysis.

<details>

<summary>Full Code</summary>

```{r}
process_quarter_conflicts <- function(region_sf, region_window, region_name, data_sf, sigma_type, kernel_method) {
  # Extract unique quarters (reversed for correct order)
  quarters <- rev(unique(data_sf$quarter_year))
  
  # Initialize empty lists to store ppp and KDE objects
  region_quarters_conflict <- list()
  kde_plot_list <- list()
  
  # Step 2: Loop over each quarter and process conflict data
  for (quarter in quarters) {
    # Filter the data for the current quarter
    quarter_data <- data_sf %>%
      filter(quarter_year == quarter)
    
    # Extract coordinates for this quarter
    quarter_coords <- st_coordinates(quarter_data)
    
    # Create a ppp object for this quarter
    quarter_ppp <- ppp(
      x = quarter_coords[, 1],
      y = quarter_coords[, 2],
      window = region_window
    )
    
    # Step 3: Remove rejected points that fall outside the window
    valid_points <- inside.owin(quarter_ppp$x, quarter_ppp$y, region_window)
    quarter_ppp <- quarter_ppp[valid_points]
    
    # Step 4: Jitter duplicates to avoid overplotting
    is_duplicate <- duplicated(quarter_ppp)
    jittered_x <- quarter_ppp$x + ifelse(is_duplicate, runif(npoints(quarter_ppp), -0.1, 0.1), 0)
    jittered_y <- quarter_ppp$y + ifelse(is_duplicate, runif(npoints(quarter_ppp), -0.1, 0.1), 0)
    
    # Create a jittered ppp object with the new coordinates
    jittered_ppp <- ppp(
      x = jittered_x,
      y = jittered_y,
      window = region_window
    )
    
    # Step 5: Store the jittered ppp object for later use
    region_quarters_conflict[[quarter]] <- jittered_ppp
    
    # Step 6: Rescale to kilometers and calculate KDE with specified sigma type and kernel method
    jittered_ppp_km <- rescale(jittered_ppp, 1000, "km")
    
    # Use selected sigma type
    if (sigma_type == "scott") {
      sigma_value <- bw.scott(jittered_ppp_km)
      kde_quarter <- density(jittered_ppp_km, sigma = bw.scott(jittered_ppp_km), edge = TRUE, kernel = kernel_method)
    } else if (sigma_type == "diggle") {
      sigma_value <- bw.scott(jittered_ppp_km)
      kde_quarter <- density(jittered_ppp_km, sigma = bw.diggle(jittered_ppp_km), edge = TRUE, kernel = kernel_method)
    } else if (sigma_type == "ppl") {
      sigma_value <- bw.scott(jittered_ppp_km)
      kde_quarter <- density(jittered_ppp_km, sigma = bw.ppl(jittered_ppp_km), edge = TRUE, kernel = kernel_method)
    } else if (sigma_type == "cvl") {
      sigma_value <- bw.scott(jittered_ppp_km)
      kde_quarter <- density(jittered_ppp_km, sigma = bw.CvL(jittered_ppp_km), edge = TRUE, kernel = kernel_method)
    } else {
      stop("Invalid sigma_type specified.")
    }
    
    # Step 7: Store the KDE object for later use
    kde_plot_list[[quarter]] <- kde_quarter
    
    # Print a message after processing each quarter
    print(paste("KDE - Quarter:", quarter, "| Kernel:", kernel_method, "| Sigma:", sigma_type, " | Sigma Value: ", sigma_value))
  }
  
  # Return the processed ppp and KDE objects
  return(list(
    "ppp_list" = region_quarters_conflict,
    "kde_list" = kde_plot_list
  ))
}

```

</details>

## 7.2 Setting up a function to display the visual across quarters

Next, we will create a function to **visualize** the KDE layers for each quarter, enabling us to compare the intensity of conflict events over time. The function will:

-   Take the KDE layers from each quarter.

-   Display them side by side or as an animation to show how conflict density changes across quarters.

-   This visualization will help us observe trends, including whether conflicts are becoming more **localized** or **dispersed** over time.

```{r}
# Visualization Function for Conflict Points and KDE
visualize_conflict_results <- function(results, region_name, sigma_type, kernel_method) {
  ppp_list <- results$ppp_list
  kde_list <- results$kde_list
  
  # Plotting Kernel Density Estimates (KDE) for each quarter
  kde_plots <- lapply(names(kde_list), function(quarter) {
    kde_data <- as.data.frame(as.im(kde_list[[quarter]]))
    
    ggplot() +
      geom_raster(data = kde_data, aes(x = x, y = y, fill = value), alpha = 0.8) +
      scale_fill_viridis_c(option = "inferno", name = "Density") +
      labs(title = paste("KDE for Civilian Conflict", region_name, "-", quarter)) +
      theme_void() +  # Removes axis, background, and grid
      theme(
        plot.title = element_text(hjust = 0.5, face = "bold", size = 10, margin = margin(t = 10, b = 10)),  # Centers and adds margin to the title
        plot.margin = margin(t = 5, r = 5, b = 5, l = 5)  # Adjusts the margin around the plot
      )
  })
  
  # Combine all plots into a grid layout with a main title
  kde_grid <- grid.arrange(grobs = kde_plots, ncol = 4, top = textGrob(
    paste(region_name, " Civilian Conflicts KDE By", sigma_type, "Using", kernel_method, "Kernel"),
    gp = gpar(fontface = "bold", fontsize = 16)
  ))
  
  return(kde_grid)
}
```

## 7.3 State's Quarterly Kernel Density estimation.

For each state, we will calculate and visualize the **Kernel Density Estimation (KDE)** using two different kernels. We focus on (You can use any we are flexible in the function above!)

-   **Kernel 1: Gaussian Kernel**

-   **Kernel 2: Epanechnikov Kernel**

The **Gaussian Kernel** is smooth and gives a global view of the density, whereas the **Epanechnikov Kernel** is more efficient and provides sharper boundaries, making it easier to identify clusters or hotspots.

We will also compute the KDE with different **bandwidths**, which controls the smoothness of the density estimates. A **larger bandwidth** results in smoother KDE, while a **smaller bandwidth** captures more local variations.

### 7.3.1 Yangon

#### **7.3.1.1 Kernel 1: Gaussian Kernel**

::: panel-tabset
## Diggle

```{r, fig.width=15, fig.height=15}
#| warning: false

Yangon_Results_Diggle_Gaussian <- process_quarter_conflicts(
  region_sf = Yangon_Sf,
  region_window = Yangon_Owin,
  region_name = "Yangon",
  data_sf = Yangon_ACLED_Data_Sf,
  sigma_type = "diggle",  # Can change to "scott", "diggle", or "ppl"
  kernel_method = "gaussian"  # Can change to "epanechnikov", "quartic", or others
)

# Step 4: Visualize the results with a main title
visualizations <- visualize_conflict_results(Yangon_Results_Diggle_Gaussian, "Yangon", "Diggle", "Gaussian")
```

## Scott

```{r, fig.width=15, fig.height=15}
#| warning: false

Yangon_Results_Scott_Gaussian <- process_quarter_conflicts(
  region_sf = Yangon_Sf,
  region_window = Yangon_Owin,
  region_name = "Yangon",
  data_sf = Yangon_ACLED_Data_Sf,
  sigma_type = "scott",  # Can change to "scott", "diggle", or "ppl"
  kernel_method = "gaussian"  # Can change to "epanechnikov", "quartic", or others
)

# Step 4: Visualize the results with a main title
Yangon_Results_Scott_Gaussian_Visualisation <- visualize_conflict_results(Yangon_Results_Scott_Gaussian, "Yangon", "Scott", "Gaussian")
```

## CvL

```{r, fig.width=15, fig.height=15}
#| warning: false

Yangon_Results_CvL_Gaussian <- process_quarter_conflicts(
  region_sf = Yangon_Sf,
  region_window = Yangon_Owin,
  region_name = "Yangon",
  data_sf = Yangon_ACLED_Data_Sf,
  sigma_type = "cvl",  # Can change to "scott", "diggle", or "ppl"
  kernel_method = "gaussian"  # Can change to "epanechnikov", "quartic", or others
)

# Step 4: Visualize the results with a main title
Yangon_Results_CvL_Gaussian_visualizations <- visualize_conflict_results(Yangon_Results_CvL_Gaussian, "Yangon", "CvL", "Gaussian")
```

## PPL

```{r, fig.width=15, fig.height=15}
#| warning: false

Yangon_Results_PPL_Gaussian <- process_quarter_conflicts(
  region_sf = Yangon_Sf,
  region_window = Yangon_Owin,
  region_name = "Yangon",
  data_sf = Yangon_ACLED_Data_Sf,
  sigma_type = "ppl",  # Can change to "scott", "diggle", or "ppl"
  kernel_method = "gaussian"  # Can change to "epanechnikov", "quartic", or others
)

# Step 4: Visualize the results with a main title
Yangon_Results_PPL_Gaussian_visualizations <- visualize_conflict_results(Yangon_Results_PPL_Gaussian, "Yangon", "PPL", "Gaussian")
```
:::

#### **7.3.1.2 Kernel 2: Epanechnikov Kernel**

::: panel-tabset
## Diggle

```{r, fig.width=15, fig.height=15}
#| warning: false

Yangon_Results_Diggle_Epanechnikov <- process_quarter_conflicts(
  region_sf = Yangon_Sf,
  region_window = Yangon_Owin,
  region_name = "Yangon",
  data_sf = Yangon_ACLED_Data_Sf,
  sigma_type = "diggle",  # Can change to "scott", "diggle", or "ppl"
  kernel_method = "epanechnikov"  # Can change to "epanechnikov", "quartic", or others
)

# Step 4: Visualize the results with a main title
Yangon_Results_Diggle_Epanechnikov_visualizations <- visualize_conflict_results(Yangon_Results_Diggle_Epanechnikov, "Yangon", "Diggle", "Epanechnikov")
```

## Scott

```{r, fig.width=15, fig.height=15}
#| warning: false

Yangon_Results_Scott_Epanechnikov <- process_quarter_conflicts(
  region_sf = Yangon_Sf,
  region_window = Yangon_Owin,
  region_name = "Yangon",
  data_sf = Yangon_ACLED_Data_Sf,
  sigma_type = "scott",  # Can change to "scott", "diggle", or "ppl"
  kernel_method = "epanechnikov"  # Can change to "epanechnikov", "quartic", or others
)

# Step 4: Visualize the results with a main title
Yangon_Results_Scot_Epanechnikov_visualizations <- visualize_conflict_results(Yangon_Results_Scott_Epanechnikov, "Yangon", "Scott", "Epanechnikov")
```

## CvL

```{r, fig.width=15, fig.height=15}
#| warning: false

Yangon_Results_CvL_Epanechnikov <- process_quarter_conflicts(
  region_sf = Yangon_Sf,
  region_window = Yangon_Owin,
  region_name = "Yangon",
  data_sf = Yangon_ACLED_Data_Sf,
  sigma_type = "cvl",  # Can change to "scott", "diggle", or "ppl"
  kernel_method = "epanechnikov"  # Can change to "epanechnikov", "quartic", or others
)

# Step 4: Visualize the results with a main title
Yangon_Results_CvL_Epanechnikov_visualizations <- visualize_conflict_results(Yangon_Results_CvL_Epanechnikov, "Yangon", "CvL", "Epanechnikov")
```

## PPL

```{r, fig.width=15, fig.height=15}
#| warning: false

Yangon_Results_PPL_Epanechnikov <- process_quarter_conflicts(
  region_sf = Yangon_Sf,
  region_window = Yangon_Owin,
  region_name = "Yangon",
  data_sf = Yangon_ACLED_Data_Sf,
  sigma_type = "ppl",  # Can change to "scott", "diggle", or "ppl"
  kernel_method = "epanechnikov"  # Can change to "epanechnikov", "quartic", or others
)

# Step 4: Visualize the results with a main title
Yangon_Results_PPL_Epanechnikov_visualizations <- visualize_conflict_results(Yangon_Results_PPL_Epanechnikov, "Yangon", "PPL", "Epanechnikov")
```
:::

### 7.3.2 Mandalay

#### **7.3.2.1 Mandalay Kernel 1: Gaussian Kernel**

::: panel-tabset
## Diggle

```{r, fig.width=15, fig.height=15}
#| warning: false

Mandalay_Results_Diggle_Gaussian <- process_quarter_conflicts(
  region_sf = Mandalay_Sf,
  region_window = Mandalay_Owin,
  region_name = "Mandalay",
  data_sf = Mandalay_ACLED_Data_Sf,
  sigma_type = "diggle",  # Can change to "scott", "diggle", or "ppl"
  kernel_method = "gaussian"  # Can change to "epanechnikov", "quartic", or others
)

# Step 4: Visualize the results with a main title
Mandalay_Results_Diggle_Gaussian_visualizations <- visualize_conflict_results(Mandalay_Results_Diggle_Gaussian, "Mandalay", "Diggle", "Gaussian")
```

## Scott

```{r, fig.width=15, fig.height=15}
#| warning: false

Mandalay_Results_Scott_Gaussian <- process_quarter_conflicts(
  region_sf = Mandalay_Sf,
  region_window = Mandalay_Owin,
  region_name = "Mandalay",
  data_sf = Mandalay_ACLED_Data_Sf,
  sigma_type = "scott",  # Can change to "scott", "diggle", or "ppl"
  kernel_method = "gaussian"  # Can change to "epanechnikov", "quartic", or others
)

# Step 4: Visualize the results with a main title
Mandalay_Results_Scott_Gaussian_visualizations <- visualize_conflict_results(Mandalay_Results_Scott_Gaussian, "Mandalay", "Scott", "Gaussian")
```

## CvL

```{r, fig.width=15, fig.height=15}
#| warning: false

Mandalay_Results_CvL_Gaussian <- process_quarter_conflicts(
  region_sf = Mandalay_Sf,
  region_window = Mandalay_Owin,
  region_name = "Mandalay",
  data_sf = Mandalay_ACLED_Data_Sf,
  sigma_type = "cvl",  # Can change to "scott", "diggle", or "ppl"
  kernel_method = "gaussian"  # Can change to "epanechnikov", "quartic", or others
)

# Step 4: Visualize the results with a main title
Mandalay_Results_CvL_Gaussian_visualizations <- visualize_conflict_results(Mandalay_Results_CvL_Gaussian, "Mandalay", "CvL", "Gaussian")
```

## PPL

```{r, fig.width=15, fig.height=15}
#| warning: false
Mandalay_Results_PPL_Gaussian <- process_quarter_conflicts(
  region_sf = Mandalay_Sf,
  region_window = Mandalay_Owin,
  region_name = "Mandalay",
  data_sf = Mandalay_ACLED_Data_Sf,
  sigma_type = "ppl",  # Can change to "scott", "diggle", or "ppl"
  kernel_method = "gaussian"  # Can change to "epanechnikov", "quartic", or others
)
# Step 4: Visualize the results with a main title
Mandalay_Results_PPL_Gaussian_visualizations <- visualize_conflict_results(Mandalay_Results_PPL_Gaussian, "Mandalay", "PPL", "Gaussian")
```
:::

#### **7.3.2.2 Mandalay Kernel 2: Epanechnikov Kernel**

::: panel-tabset
## Diggle

```{r, fig.width=15, fig.height=15}
#| warning: false

Mandalay_Results_Diggle_Epanechnikov <- process_quarter_conflicts(
  region_sf = Mandalay_Sf,
  region_window = Mandalay_Owin,
  region_name = "Mandalay ",
  data_sf = Mandalay_ACLED_Data_Sf,
  sigma_type = "diggle",  # Can change to "scott", "diggle", or "ppl"
  kernel_method = "epanechnikov"  # Can change to "epanechnikov", "quartic", or others
)

# Step 4: Visualize the results with a main title
Mandalay_Results_Diggle_Epanechnikov_visualizations <- visualize_conflict_results(Mandalay_Results_Diggle_Epanechnikov, "Mandalay ", "Diggle", "Epanechnikov")
```

## Scott

```{r, fig.width=15, fig.height=15}
#| warning: false

Mandalay_Results_Scott_Epanechnikov <- process_quarter_conflicts(
  region_sf = Mandalay_Sf,
  region_window = Mandalay_Owin,
  region_name = "Mandalay ",
  data_sf = Mandalay_ACLED_Data_Sf,
  sigma_type = "scott",  # Can change to "scott", "diggle", or "ppl"
  kernel_method = "epanechnikov"  # Can change to "epanechnikov", "quartic", or others
)

# Step 4: Visualize the results with a main title
Mandalay_Results_Scott_Epanechnikov_visualizations <- visualize_conflict_results(Mandalay_Results_Scott_Epanechnikov, "Mandalay ", "Scott", "Epanechnikov")
```

## CvL

```{r, fig.width=15, fig.height=15}
#| warning: false
Mandalay_Results_CvL_Epanechnikov <- process_quarter_conflicts(
  region_sf = Mandalay_Sf,
  region_window = Mandalay_Owin,
  region_name = "Mandalay ",
  data_sf = Mandalay_ACLED_Data_Sf,
  sigma_type = "cvl",  # Can change to "scott", "diggle", or "ppl"
  kernel_method = "epanechnikov"  # Can change to "epanechnikov", "quartic", or others
)

# Step 4: Visualize the results with a main title
Mandalay_Results_CvL_Epanechnikov_visualizations <- visualize_conflict_results(Mandalay_Results_CvL_Epanechnikov, "Mandalay ", "CvL", "Epanechnikov")
```

## PPL

```{r, fig.width=15, fig.height=15}
#| warning: false

Mandalay_Results_PPL_Epanechnikov <- process_quarter_conflicts(
  region_sf = Mandalay_Sf,
  region_window = Mandalay_Owin,
  region_name = "Mandalay",
  data_sf = Mandalay_ACLED_Data_Sf,
  sigma_type = "ppl",  # Can change to "scott", "diggle", or "ppl"
  kernel_method = "epanechnikov"  # Can change to "epanechnikov", "quartic", or others
)

# Step 4: Visualize the results with a main title
Mandalay_Results_PPL_Epanechnikov_visualizations <- visualize_conflict_results(Mandalay_Results_PPL_Epanechnikov, "Mandalay ", "PPL", "Epanechnikov")
```
:::

### 7.3.3 Sagaing

#### **7.3.3.1 Sagaing Kernel 1: Gaussian Kernel**

::: panel-tabset
## Diggle

```{r, fig.width=15, fig.height=15}
#| warning: false

Sagaing_Results_Diggle_Gaussian <- process_quarter_conflicts(
  region_sf = Sagaing_Sf,
  region_window = Sagaing_Owin,
  region_name = "Sagaing",
  data_sf = Sagaing_ACLED_Data_Sf,
  sigma_type = "diggle",  # Can change to "scott", "diggle", or "ppl"
  kernel_method = "gaussian"  # Can change to "epanechnikov", "quartic", or others
)

# Step 4: Visualize the results with a main title
Sagaing_Results_Diggle_Gaussian_visualizations <- visualize_conflict_results(Sagaing_Results_Diggle_Gaussian, "Sagaing", "Diggle", "Gaussian")
```

## Scott

```{r, fig.width=15, fig.height=15}
#| warning: false

Sagaing_Results_Scott_Gaussian <- process_quarter_conflicts(
  region_sf = Sagaing_Sf,
  region_window = Sagaing_Owin,
  region_name = "Sagaing",
  data_sf = Sagaing_ACLED_Data_Sf,
  sigma_type = "scott",  # Can change to "scott", "diggle", or "ppl"
  kernel_method = "gaussian"  # Can change to "epanechnikov", "quartic", or others
)

# Step 4: Visualize the results with a main title
Sagaing_Results_Scott_Gaussian_visualizations <- visualize_conflict_results(Sagaing_Results_Scott_Gaussian, "Sagaing", "Scott", "Gaussian")
```

## CvL

```{r, fig.width=15, fig.height=15}
#| warning: false

Sagaing_Results_CVL_Gaussian <- process_quarter_conflicts(
  region_sf = Sagaing_Sf,
  region_window = Sagaing_Owin,
  region_name = "Sagaing",
  data_sf = Sagaing_ACLED_Data_Sf,
  sigma_type = "cvl",  # Can change to "scott", "diggle", or "ppl"
  kernel_method = "gaussian"  # Can change to "epanechnikov", "quartic", or others
)

# Step 4: Visualize the results with a main title
Sagaing_Results_CVL_Gaussian_visualizations <- visualize_conflict_results(Sagaing_Results_CVL_Gaussian, "Sagaing", "CVL", "Gaussian")
```

## PPL

```{r, fig.width=15, fig.height=15}
#| warning: false

Sagaing_Results_PPL_Gaussian <- process_quarter_conflicts(
  region_sf = Sagaing_Sf,
  region_window = Sagaing_Owin,
  region_name = "Sagaing",
  data_sf = Sagaing_ACLED_Data_Sf,
  sigma_type = "ppl",  # Can change to "scott", "diggle", or "ppl"
  kernel_method = "gaussian"  # Can change to "epanechnikov", "quartic", or others
)

# Step 4: Visualize the results with a main title
Sagaing_Results_PPL_Gaussian_visualizations <- visualize_conflict_results(Sagaing_Results_PPL_Gaussian, "Sagaing", "PPL", "Gaussian")
```
:::

#### **7.3.3.2 Sagaing Kernel 2: Epanechnikov Kernel**

::: panel-tabset
## Diggle

```{r, fig.width=15, fig.height=15}
#| warning: false

Sagaing_Results_Diggle_Epanechnikov <- process_quarter_conflicts(
  region_sf = Sagaing_Sf,
  region_window = Sagaing_Owin,
  region_name = "Sagaing",
  data_sf = Sagaing_ACLED_Data_Sf,
  sigma_type = "diggle",  # Can change to "scott", "diggle", or "ppl"
  kernel_method = "epanechnikov"  # Can change to "epanechnikov", "quartic", or others
)

# Step 4: Visualize the results with a main title
Sagaing_Results_Diggle_Epanechnikov_visualizations <- visualize_conflict_results(Sagaing_Results_Diggle_Epanechnikov, "Sagaing", "Diggle", "Epanechnikov")
```

## Scott

```{r, fig.width=15, fig.height=15}
#| warning: false

Sagaing_Results_Scott_Epanechnikov <- process_quarter_conflicts(
  region_sf = Sagaing_Sf,
  region_window = Sagaing_Owin,
  region_name = "Sagaing",
  data_sf = Sagaing_ACLED_Data_Sf,
  sigma_type = "scott",  # Can change to "scott", "diggle", or "ppl"
  kernel_method = "epanechnikov"  # Can change to "epanechnikov", "quartic", or others
)

# Step 4: Visualize the results with a main title
Sagaing_Results_Scott_Epanechnikov_visualizations <- visualize_conflict_results(Sagaing_Results_Scott_Epanechnikov, "Sagaing", "Scott", "Epanechnikov")
```

## CvL

```{r, fig.width=15, fig.height=15}
#| warning: false

Sagaing_Results_Cvl_Epanechnikov <- process_quarter_conflicts(
  region_sf = Sagaing_Sf,
  region_window = Sagaing_Owin,
  region_name = "Sagaing",
  data_sf = Sagaing_ACLED_Data_Sf,
  sigma_type = "cvl",  # Can change to "scott", "diggle", or "ppl"
  kernel_method = "epanechnikov"  # Can change to "epanechnikov", "quartic", or others
)

# Step 4: Visualize the results with a main title
Sagaing_Results_CvL_Epanechnikov_visualizations <- visualize_conflict_results(Sagaing_Results_Cvl_Epanechnikov, "Sagaing", "CvL", "Epanechnikov")
```

## PPL

```{r, fig.width=15, fig.height=15}
#| warning: false

Sagaing_Results_PPL_Epanechnikov <- process_quarter_conflicts(
  region_sf = Sagaing_Sf,
  region_window = Sagaing_Owin,
  region_name = "Sagaing",
  data_sf = Sagaing_ACLED_Data_Sf,
  sigma_type = "ppl",  # Can change to "scott", "diggle", or "ppl"
  kernel_method = "epanechnikov"  # Can change to "epanechnikov", "quartic", or others
)

# Step 4: Visualize the results with a main title
Sagaing_Results_PPL_Epanechnikov_visualizations <- visualize_conflict_results(Sagaing_Results_PPL_Epanechnikov, "Sagaing", "PPL", "Epanechnikov")
```
:::

# 8.0 **Perform 2nd-Order Spatial Point Pattern Analysis**

In this analysis, we aim to determine whether conflicts are **clustered** or **randomly distributed** within the study area. To achieve this, we use **2nd-order spatial point pattern analysis**, which examines the relationships between individual conflict events at varying distances. This helps us detect patterns of clustering or dispersion across the state.

### **Why Use Only K and L Functions**

We focus on the **K Function** and **L Function** because they provide the most straightforward and effective means of identifying clustering or dispersion. The **K Function** measures clustering at multiple scales, while the **L Function** simplifies interpretation by stabilizing variance, making it easier to identify spatial patterns in conflict events. These methods are ideal for capturing the **spatial structure** of conflicts across varying distances.

## 8.1 Yangon

### 8.1.1 K Function

#### 8.1.1.1 Code to Generate

```{r}
# Step 1: Calculate the K-function (Ripley's K) for Yangon
K_Yangon <- Kest(Yangon_ACLED_ppp, correction = "Ripley")

# Step 2: Plot the K-function, showing K(d) - r
plot(K_Yangon, . -r ~ r, ylab = "K(d) - r", xlab = "d(m)", main = "Ripley's K-Function for Yangon Conflicts")

# Step 3: Set seed for reproducibility before running the envelope test
set.seed(1227)

# Step 4: Perform the envelope test for CSR (Complete Spatial Randomness) using the K-function
# 30 simulations, but with maximum resource usage
K_Yangon_CSR <- envelope(Yangon_ACLED_ppp, Kest, nsim = 30, rank = 1, global = TRUE)

# Step 5: Calculate the p-value for K-Function
p_value_K <- attr(K_Yangon_CSR, "rank") / (attr(K_Yangon_CSR, "nsim") + 1)

# Print the calculated p-value
print(paste("P-value for K-Function:", p_value_K))

# Step 6: Plot the envelope to observe deviation from CSR
plot(K_Yangon_CSR, . - r ~ r, xlab = "d", ylab = "K(d) - r", main = "Envelope for K-Function (CSR) - Yangon Conflicts")
```

#### 8.1.1.2 Analysis

Ho = The distribution of civilian related conflcits at Yangon **are** randomly distributed.

H1= The distribution of civilian related conflcits at Yangon **are not** randomly distributed.

*The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.*

![](images/clipboard-2422732252.png)

### 8.1.2 L Functions

#### 8.1.2.1 Code to Generate

```{r}
L_Yangon <- Lest(Yangon_ACLED_ppp, correction = "Ripley")

# Step 2: Plot the L-function, showing L(d) - r
plot(L_Yangon, . -r ~ r, ylab = "L(d) - r", xlab = "d(m)", main = "Ripley's L-Function for Yangon Conflicts")

# Step 3: Set seed for reproducibility before running the envelope test

# Step 4: Perform the envelope test for CSR (Complete Spatial Randomness) using the L-function
# Save the functions used in the simulations for p-value calculation
L_Yangon_CSR <- envelope(Yangon_ACLED_ppp, Lest, nsim = 30, rank = 1, global = TRUE, savefuns = TRUE)

# Step 5: Calculate the p-value for L-Function
p_value_L <- attr(L_Yangon_CSR, "rank") / (attr(L_Yangon_CSR, "nsim") + 1)

# Print the calculated p-value
print(paste("P-value for L-Function:", p_value_L))

# Step 6: Plot the envelope to observe deviation from CSR
plot(L_Yangon_CSR, . - r ~ r, xlab = "d", ylab = "L(d) - r", main = "Envelope for L-Function (CSR) - Yangon Conflicts")
```

## 8.2 Mandalay

```{r}
# Step 1: Calculate the K-function (Ripley's K) for Mandalay
K_Mandalay <- Kest(Mandalay_ACLED_ppp, correction = "Ripley")

# Step 2: Plot the K-function, showing K(d) - r
plot(K_Mandalay, . -r ~ r, ylab = "K(d) - r", xlab = "d(m)", main = "Ripley's K-Function for Mandalay Conflicts")

# Step 3: Set seed for reproducibility before running the envelope test
set.seed(1227)

# Step 4: Perform the envelope test for CSR (Complete Spatial Randomness) using the K-function
# 30 simulations, but with maximum resource usage
K_Mandalay_CSR <- envelope(Mandalay_ACLED_ppp, Kest, nsim = 30, rank = 1, global = TRUE)

# Step 5: Calculate the p-value for K-Function
p_value_K <- attr(K_Mandalay_CSR, "rank") / (attr(K_Mandalay_CSR, "nsim") + 1)

# Print the calculated p-value
print(paste("P-value for K-Function:", p_value_K))

# Step 6: Plot the envelope to observe deviation from CSR
plot(K_Mandalay_CSR, . - r ~ r, xlab = "d", ylab = "K(d) - r", main = "Envelope for K-Function (CSR) - Mandalay Conflicts")
```

```{r}
L_Mandalay <- Lest(Mandalay_ACLED_ppp, correction = "Ripley")

# Step 2: Plot the L-function, showing L(d) - r
plot(L_Mandalay, . -r ~ r, ylab = "L(d) - r", xlab = "d(m)", main = "Ripley's L-Function for Mandalay Conflicts")

# Step 3: Set seed for reproducibility before running the envelope test

# Step 4: Perform the envelope test for CSR (Complete Spatial Randomness) using the L-function
# Save the functions used in the simulations for p-value calculation
L_Mandalay_CSR <- envelope(Mandalay_ACLED_ppp, Lest, nsim = 30, rank = 1, global = TRUE, savefuns = TRUE)

# Step 5: Calculate the p-value for L-Function
p_value_L <- attr(L_Mandalay_CSR, "rank") / (attr(L_Mandalay_CSR, "nsim") + 1)

# Print the calculated p-value
print(paste("P-value for L-Function:", p_value_L))

# Step 6: Plot the envelope to observe deviation from CSR
plot(L_Mandalay_CSR, . - r ~ r, xlab = "d", ylab = "L(d) - r", main = "Envelope for L-Function (CSR) - Mandalay Conflicts")
```

## 8.3 Sagaing

For the **Sagaing conflict events**, we'll perform a detailed spatial point pattern analysis using the **Clark-Evans test**, **Ripley’s K-function**, and **L-function**. This will help us understand whether the conflict events are randomly distributed, clustered, or dispersed, and at what scales clustering occurs.

### **Null and Alternative Hypothesis:**

-   **Ho (Null Hypothesis):** The distribution of civilian-related conflicts in **Sagaing** is **randomly distributed** (CSR: Complete Spatial Randomness).

-   **H1 (Alternative Hypothesis):** The distribution of civilian-related conflicts in **Sagaing** is **not randomly distributed** (it is clustered or dispersed).

### 8.3.1 Clarks Evan Test

```{r}
# Perform the Clark-Evans test for clustering
Sagaing_ClarksEvan <- clarkevans(Sagaing_ACLED_ppp, 
                              correction = "none", 
                              clipregion = "Sagaing_owin", 
                              alternative = c("clustered"),
                              nsim = 30)

# Print Clark-Evans p-value and R-statistic
print(Sagaing_ClarksEvan)
```

### 8.3.2 K-Function Method

#### 8.3.2.1 K-function Graph's

::: panel-tabset
## K-Function Data

```{r}
K_Sagaing <- Kest(Sagaing_ACLED_ppp, correction = "Ripley")

# Step 2: Plot the K-function, showing K(d) - r
plot(K_Sagaing, . -r ~ r, ylab = "K(d) - r", xlab = "d(KM)", main = "Ripley's K-Function for Sagaing Civilian Related Conflicts")
```

## Envelope Test

```{r}
K_Sagaing_CSR <- envelope(Sagaing_ACLED_ppp, Kest, nsim = 30, rank = 1, global = TRUE)

# Step 6: Plot the envelope to observe deviation from CSR
plot(K_Sagaing_CSR, . - r ~ r, xlab = "d(KM)", ylab = "K(d) - r", main = "Envelope for K-Function (CSR) - Sagaing Conflicts")
```
:::

#### 8.3.2.2 Observed Table (K-Function at Key Distances)

```{r}
# Step 1: Define key distances (e.g., 20000m, 30000m, 40000m)
key_distances <- c(20, 30, 40,50,60,70)

# Step 2: Extract observed K-function values and CSR bounds at distances closest to key distances
closest_indices <- sapply(key_distances, function(d) which.min(abs(K_Sagaing_CSR$r - d)))

# Step 3: Create a table summarizing observed and CSR envelope bounds at the closest distances
observed_table <- data.frame(
  Distance = K_Sagaing_CSR$r[closest_indices],       # Actual distances used in the analysis
  K_Obs = K_Sagaing_CSR$obs[closest_indices],        # Observed K-function values
  K_Lo = K_Sagaing_CSR$lo[closest_indices],          # Lower bound of CSR envelope
  K_Hi = K_Sagaing_CSR$hi[closest_indices]           # Upper bound of CSR envelope
)

# Display the observed table
print(observed_table)

```

### 8.3.3 L-Function Method

::: panel-tabset
## L Function

```{r}
# Step 1: Calculate the L-function (Ripley's L) for Sagaing conflicts
L_Sagaing <- Lest(Sagaing_ACLED_ppp, correction = "Ripley")

# Step 2: Plot the L-function, showing L(d) - r
plot(L_Sagaing, . - r ~ r, ylab = "L(d) - r", xlab = "d(km)", main = "Ripley's L-Function for Sagaing Civilian Related Conflicts")
```

## CSR Envelope

```{r}
L_Sagaing_CSR <- envelope(Sagaing_ACLED_ppp, Lest, nsim = 30, rank = 1, global = TRUE)

# Step 6: Plot the envelope to observe deviation from CSR
plot(L_Sagaing_CSR, . - r ~ r, xlab = "d(KM)", ylab = "K(d) - r", main = "Envelope for L-Function (CSR) - Sagaing Civilian Related Conflicts")
```
:::

#### 8.3.3.3 Observed Table (L-Function at Key Distances)

```{r}
key_distances <- c(20, 30, 40,50,60,70)

# Step 2: Extract observed K-function values and CSR bounds at distances closest to key distances
closest_indices <- sapply(key_distances, function(d) which.min(abs(L_Sagaing_CSR$r - d)))

# Step 3: Create a table summarizing observed and CSR envelope bounds at the closest distances
observed_table <- data.frame(
  Distance = L_Sagaing_CSR$r[closest_indices],       # Actual distances used in the analysis
  K_Obs = L_Sagaing_CSR$obs[closest_indices],        # Observed K-function values
  K_Lo = L_Sagaing_CSR$lo[closest_indices],          # Lower bound of CSR envelope
  K_Hi = L_Sagaing_CSR$hi[closest_indices]           # Upper bound of CSR envelope
)

# Display the observed table
print(observed_table)

```

### 8.3.4 Sagaing - Analysis and Interpretation

Based on the analysis of the **Clark-Evans test**, **K-function**, and **L-function**, we can draw the following conclusions:

1.  **Clark-Evans Test**:

    -   The **R-value** is less than 1, and the **p-value** is very small, which means the conflict events in **Sagaing** are **not randomly distributed** and are significantly **clustered**.

2.  **K-function Analysis**:

    -   The **observed K-function** consistently exceeds the **upper bound** of the CSR envelope across all distances, indicating that the **clustering** is prominent over a wide range of distances (up to 70km). The clustering becomes more pronounced as the distance increases.

3.  **L-function Analysis**:

    -   The **observed L-function** also exceeds the CSR envelope's upper bounds, confirming the presence of clustering at multiple spatial scales. This supports the findings from the K-function.

4.  **Observed Tables**:

    -   The **observed K-function** and **L-function** tables confirm that the observed values are significantly higher than the expected values under CSR, particularly at distances of 20km, 30km, 40km, and beyond, suggesting clustering at larger spatial scales.

We reject the **null hypothesis** of **Complete Spatial Randomness (CSR)** for **Sagaing civilian-related conflicts**. The Clark-Evans test shows significant clustering, and both the K-function and L-function support this finding by indicating clustering over a broad range of distances. The observed tables further confirm this, as the observed values consistently exceed the CSR bounds. Therefore, the conflict events in Sagaing are significantly **clustered** rather than randomly distributed.

# 9.0 **Derive Quarterly Spatio-Temporal KDE Layers**:

```{r}
library(animation)
saveGIF({
  # Loop over the valid quarter times
  for(i in tims){ 
    plot(Yangon_Month_KDE, i, 
         override.par=FALSE, 
         fix.range=TRUE, 
         main=paste("KDE at quarter", i))
  }
}, movie.name = "kde_animation.gif", interval = 0.5, ani.width = 800, ani.height = 800)
```

```{r, fig.width=15, fig.height=15}
# Step 1: Ensure Yangon_QuarterYear_Sf is an sf object (if not already)
Yangon_QuarterYear_Sf <- st_as_sf(Yangon_ACLED_Data_Sf)

# Step 2: Extract the coordinates (longitude and latitude) from the geometry column
coords <- st_coordinates(Yangon_QuarterYear_Sf)

# Step 3: Convert quarter_numeric to factor for distinct quarters (for plotting the circles)
Yangon_QuarterYear_Sf <- Yangon_QuarterYear_Sf %>%
  mutate(
    year = as.numeric(sub(".*-", "", quarter_year)),                  # Extract the year (e.g., 2023)
    quarter = as.numeric(sub("Q", "", sub("-.*", "", quarter_year))), # Extract the quarter (e.g., Q1 -> 1)
    
    # Continuous representation of time (factor for distinct quarters)
    quarter_numeric_factor = as.factor(year * 10 + quarter),  # Convert to factor for plotting the circles
    quarter_numeric = year * 10 + quarter  # Keep as numeric for time-based KDE analysis
  )

# Step 4: Create the point pattern object using ppp() with factor marks (for distinct quarter plotting)
Yangon_QuarterYear_PPP_Factor <- ppp(
  x = coords[, 1],  # Longitude (x-coordinates)
  y = coords[, 2],  # Latitude (y-coordinates)
  window = Yangon_Owin,  # Spatial window (Yangon_Owin)
  marks = Yangon_QuarterYear_Sf$quarter_numeric_factor  # Use factor for visualizing distinct quarters
)

# Step 5: Assign 14 unique sizes to the 14 unique quarter_numeric values
# Create 14 different circle sizes, e.g., from 1 to 3 in size
unique_quarters <- levels(Yangon_QuarterYear_Sf$quarter_numeric_factor)  # Get the unique quarter levels (14 levels)
circle_sizes <- seq(1, 3, length.out = length(unique_quarters))  # Generate 14 sizes from 1 to 3

# Map each unique quarter_numeric level to a circle size
circle_size_map <- setNames(circle_sizes, unique_quarters)  # Create a named vector to map quarter to size

# Apply the circle size mapping to each point based on its quarter_numeric_factor
point_circle_sizes <- circle_size_map[Yangon_QuarterYear_Sf$quarter_numeric_factor]

# Step 6: Plot the base map (Yangon_Owin) without points
plot(Yangon_Owin, main = "Yangon Quarter-Year Owin with Unique Circle Sizes")

# Step 7: Add the points with the unique circle sizes based on quarter_numeric
points(coords[, 1], coords[, 2], cex = point_circle_sizes, pch = 16, col = "black")  # Add circles on top of base map

# Step 8: Add a custom legend to show the quarter_numeric values and corresponding circle sizes
legend("topright", legend = unique_quarters, 
       pch = 16, 
       pt.cex = circle_sizes,  # Show unique circle sizes in the legend
       col = "black", 
       title = "Quarters (Circle Size)")
```

```{r, fig.width=15, fig.height=15}
Yangon_QuarterYear_PPP_Numeric <- ppp(
  x = coords[, 1],  # Longitude (x-coordinates)
  y = coords[, 2],  # Latitude (y-coordinates)
  window = Yangon_Owin,  # Spatial window (Yangon_Owin)
  marks = Yangon_QuarterYear_Sf$quarter_numeric  # Use numeric for KDE analysis (time-based)
)

# Step 10: Perform KDE analysis using the spatio-temporal density function
Yangon_QuarterYear_KDE <- spattemp.density(Yangon_QuarterYear_PPP_Numeric)

# Step 11: Define the quarters for which you want to plot the KDE
tims <- c(20211, 20212, 20213, 20214, 20221, 20222, 20223, 20224, 
          20231, 20232, 20233, 20234, 20241, 20242)

# Step 12: Set up the plotting window to display multiple plots in a grid (4x4)
par(mfcol=c(4,4))  # 4 rows, 4 columns layout for the plots

# Step 13: Loop through the 'tims' vector and plot the KDE for each time point
for(i in tims) { 
    plot(Yangon_QuarterYear_KDE, i, 
         override.par=FALSE,  # Keep the graphical parameters unchanged
         fix.range=TRUE,      # Fix the range of the KDE
         main=paste("KDE at Quarter", i))  # Title for each plot
}
```

# 10.0 **Perform 2nd-Order Spatio-Temporal Point Patterns Analysis**:

In this analysis, we aim to determine whether civilian related conflict events in **State** are clustered or randomly distributed in **both space and time**. To achieve this, we use **spatio-temporal point pattern analysis**, which examines the relationships between individual conflict events at varying distances and times. This approach allows us to detect patterns of clustering or dispersion across both spatial and temporal scales.

## 10.1 Yangon

For the conflict events in Yangon, we performed a detailed **spatio-temporal point pattern analysis** using the **Clark-Evans test** for spatial randomness, and the **spatio-temporal K-function** to explore clustering across both space and time. This analysis helps us understand whether the conflict events are randomly distributed, clustered, or dispersed, and at what spatial and temporal scales these patterns emerge.

### Null and Alternative Hypotheses:

-   **Ho (Null Hypothesis)**: The distribution of conflict events in Yangon follows **Complete Spatio-Temporal Randomness (CSTR)**, meaning the events are randomly distributed in both space and time.

-   **H1 (Alternative Hypothesis)**: The distribution of conflict events in Yangon **does not follow CSTR** and instead shows signs of clustering or dispersion in both space and time.

### 10.1.1.1 Yangon's Clark-Evans Test for Spatial Randomness:

```{r}

L_Sagaing_ST <- Lest(Yangon_QuarterYear_PPP_Numeric, correction = "Ripley")

# Step 2: Plot the L-function, showing L(d) - r
plot(L_Sagaing_ST, . - r ~ r, ylab = "L(d) - r", xlab = "d(km)", main = "Ripley's L-Function for Sagaing Civilian Related Conflicts")


```

```{r}
Yangon_Kest_env <- envelope(Yangon_QuarterYear_PPP_Numeric, Kest, nsim=30, 
                            global=TRUE, verbose=FALSE)

# Plot the K-function with the CSR envelope to visualize clustering in space and time
plot(Yangon_Kest_env, main="Spatio-temporal K-function with Monte Carlo CSR Envelope")
```

```{r}

```

# 11.0 Results and Interpretation

# 12.0 Conclusion

# 13.0 References
