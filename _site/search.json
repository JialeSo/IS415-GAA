[
  {
    "objectID": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html",
    "href": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html",
    "title": "Take_Home Exercise 1: Geospatial Analytics for Social Good: Application of Spatial and Spatio-temporal Point Patterns Analysis to discover the geographical distribution of Armed Conflict in Myanmar",
    "section": "",
    "text": "The study of armed conflicts in Myanmar has gained critical importance in understanding the geographical distribution and intensity of violence across different regions. Myanmar’s complex ethnic composition and ongoing civil strife make it a unique case for geospatial analysis. This project aims to apply spatial and spatio-temporal point pattern analysis methods to uncover the patterns of armed conflict between January 2021 and June 2024.\nBy leveraging conflict data from the Armed Conflict Location & Event Data (ACLED) and geospatial tools, we will focus on visualizing and interpreting conflict density through heat maps, Kernel Density Estimation (KDE), and advanced spatio-temporal analysis.\n\nOur analysis will focus on four types of conflict events:\n\nBattles,\nExplosion/Remote violence,\nStrategic developments,\nViolence against civilians,\n\nwith particular attention paid to quarterly patterns in conflict occurrence."
  },
  {
    "objectID": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#installing-the-required-packages",
    "href": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#installing-the-required-packages",
    "title": "Take_Home Exercise 1: Geospatial Analytics for Social Good: Application of Spatial and Spatio-temporal Point Patterns Analysis to discover the geographical distribution of Armed Conflict in Myanmar",
    "section": "2.1 Installing the required Packages",
    "text": "2.1 Installing the required Packages\nKey Packages Used in the Project:\n\nsf: Handles simple features in R, allowing for spatial data manipulation and analysis. It is crucial for reading and managing geospatial data like shapefiles (e.g., Myanmar’s administrative boundaries).\nraster: Used for raster-based spatial data manipulation, especially for working with raster maps, such as Kernel Density Estimation (KDE) results.\nspatstat: A powerful package for spatial point pattern analysis. It helps to analyze and visualize spatial point data, particularly for identifying clusters or patterns in armed conflict events.\nsparr: Builds on spatstat and focuses on performing spatial and spatio-temporal kernel smoothing, which will be crucial for KDE and heatmap creation.\ntmap: A thematic mapping package that will allow us to create maps, including KDE visualizations on an OpenStreetMap base.\ntidyverse: A collection of data manipulation packages like dplyr, ggplot2, and purrr. It’s essential for data cleaning, manipulation, and visualization tasks.\nstpp: Used for spatio-temporal point pattern analysis, crucial for analyzing how conflict events evolve in both space and time.\nskimr: A quick and comprehensive tool to provide summaries and descriptive statistics for datasets, helping in the initial exploration.\ngganimate: Extends ggplot2 to create animated visualizations. We can use this for animated time-series or evolving conflict maps.\nggplot2: The core plotting package in R, essential for creating visualizations like time series plots and KDE heatmaps.\nplotly: Useful for creating interactive visualizations, allowing users to explore spatial data interactively (e.g., hover over points to see conflict details).\npacman: is a package management tool in R designed to streamline the process of loading and installing packages.\n\n\npacman::p_load(sf, raster, spatstat, sparr, tmap, tidyverse, stpp, skimr, gganimate, ggplot2, plotly, flexdashboard, DT,gridExtra, rlist, grid, animation)"
  },
  {
    "objectID": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#data-set-involved-in-this-topic",
    "href": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#data-set-involved-in-this-topic",
    "title": "Take_Home Exercise 1: Geospatial Analytics for Social Good: Application of Spatial and Spatio-temporal Point Patterns Analysis to discover the geographical distribution of Armed Conflict in Myanmar",
    "section": "2.2 Data-set involved in this topic",
    "text": "2.2 Data-set involved in this topic\nFor this analysis, we use two key datasets:\n\n2.2.1 ACLED Armed Conflict Data\nLocation & Event Data (ACLED)platform, which maintains an extensive record of conflict events globally. For this specific analysis, we will limit the dataset by filtering based on the following parameters to streamline data preparation and minimize the need for extensive data cleaning:\n\n\n\n\n\n\n\nData Parameter\nFilter Category\n\n\n\n\nDate Range\nFrom 01/01/2021 to 30/06/2024.\n\n\nEvent Type\n1. Battles\n2. Violence Against Civilians\n3. Explosions/Remote Violence\n4. Strategic Developments\n\n\nCountry\nMyanmar\n\n\n\n\n\nACLED Configuration Image\n\n\n\n\n\nCode to Import ACLED Dataset\n\n\nACLEDData &lt;- read_csv(\"data/raw/aspatial/2021-01-01-2024-06-30-Myanmar.csv\")\n\nRows: 42608 Columns: 35\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (20): event_id_cnty, event_date, disorder_type, event_type, sub_event_ty...\ndbl (15): year, time_precision, inter1, inter2, interaction, iso, latitude, ...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\n\n2.2.1.1 Understanding the data set fields.\nReferencing this ACLED Official codebook, this is the dataset that we are working with, not to bore you with the details are mainly interested in the following fields,\n\nEvent ID: Unique identifier for each conflict event.\nEvent Date: Date of occurrence.\nEvent Type: Type of conflict event (e.g., Battles, Remote Violence).\nLatitude/Longitude: Coordinates of the event.\nFatalities: Number of fatalities resulting from the event.\nActors: The groups or individuals involved in the conflict (e.g., state actors, ethnic armed groups).\nAdmin Levels: Administrative region, district, and township where the event took place.\n\nIf you’re interested in the data set fields to explore more, here’s the full fields!\n\n\nACLED Full Table Fields Summary\n\n\n\n\nFields name\nFields Description\nValues\n\n\nevent_id_cnty\nA unique alphanumeric event identifier by number and country acronym. This identifier remains constant even when the event details are updated.\nE.g. ETH9766\n\n\nevent_date\nThe date on which the event took place. Recorded as Year-Month-Day.\nE.g. 2023-02-16\n\n\nyear\nThe year in which the event took place.\nE.g. 2018\n\n\ntime_precision\nA numeric code between 1 and 3 indicating the level of precision of the date recorded for the event. The higher the number, the lower the precision.\n1, 2, or 3; with 1 being the most precise.\n\n\ndisorder_type\nThe disorder category an event belongs to.\nPolitical violence, Demonstrations, or Strategic developments.\n\n\nevent_type\nThe type of event; further specifies the nature of the event.\nE.g. BattlesFor the full list of ACLED event types, see the ACLED Event Types table.\n\n\nsub_event_type\nA subcategory of the event type.\nE.g. Armed clashFor the full list of ACLED sub-event types, see the ACLED Event Types table.\n\n\nactor1\nOne of two main actors involved in the event (does not necessarily indicate the aggressor).\nE.g. Rioters (Papua New Guinea)\n\n\nassoc_actor_1\nActor(s) involved in the event alongside ‘Actor 1’ or actor designations that further identify ‘Actor 1’.\nE.g. Labor Group (Spain); Women (Spain)Can have multiple actors separated by a semicolon, or can be blank.\n\n\ninter1\nA numeric code between 0 and 8 indicating the type of ‘Actor 1’ (for more, see the section Actor Names, Types, and ‘Inter’ Codes).\n1, 2, 3, 4, 5, 6, 7, or 8.\n\n\nactor2\nOne of two main actors involved in the event (does not necessarily indicate the target or victim).\nE.g. Civilians (Kenya)Can be blank.\n\n\nassoc_actor_2\nActor(s) involved in the event alongside ‘Actor 2’ or actor designation further identifying ‘Actor 2’.\nE.g. Labor Group (Spain); Women (Spain)Can have multiple actors separated by a semicolon, or can be blank.\n\n\ninter2\nA numeric code between 0 to 8 indicating the type of ‘Actor 2’ (for more, see the section Actor Names, Types, and ‘Inter’ Codes).\n0, 1, 2, 3, 4, 5, 6, 7, or 8.\n\n\ninteraction\nA two-digit numeric code (combination of ‘Inter 1’ and ‘Inter 2’) indicating the two actor types interacting in the event (for more, see the section Actor Names, Types, and ‘Inter’ Codes).\nE.g.3, 58\n\n\ncivilian_targeting\nThis column indicates whether the event involved civilian targeting.\nEither ‘Civilians targeted’ or blank.\n\n\niso\nA unique three-digit numeric code assigned to each country or territory according to ISO 3166.\nE.g. 231 for Ethiopia\n\n\nregion\nThe region of the world where the event took place.\nE.g. Eastern Africa\n\n\ncountry\nThe country or territory in which the event took place.\nE.g. Ethiopia\n\n\nadmin1\nThe largest sub-national administrative region in which the event took place.\nE.g. Oromia\n\n\nadmin2\nThe second largest sub-national administrative region in which the event took place.\nE.g. ArsiCan be blank.\n\n\nadmin3\nThe third largest sub-national administrative region in which the event took place.\nE.g. MertiCan be blank.\n\n\nlocation\nThe name of the location at which the event took place.\nE.g. Abomsa\n\n\nlatitude\nThe latitude of the location in four decimal degrees notation (EPSG:32647).\nE.g. 8.5907\n\n\nlongitude\nThe longitude of the location in four decimal degrees notation (EPSG:32647).\nE.g. 39.8588\n\n\ngeo_precision\nA numeric code between 1 and 3 indicating the level of certainty of the location recorded for the event. The higher the number, the lower the precision.\n1, 2, or 3; with 1 being the most precise.\n\n\nsource\nThe sources used to record the event. Separated by a semicolon.\nE.g. Ansar Allah; Yemen Data Project\n\n\nsource_ scale\nAn indication of the geographic closeness of the used sources to the event (for more, see the section Source Scale).\nE.g. Local partner-National\n\n\nnotes\nA short description of the event.\nE.g. On 16 February 2023, OLF-Shane abducted an unidentified number of civilians after stopping a vehicle in an area near Abomsa (Merti, Arsi, Oromia). The abductees were traveling from Adama to Abomsa, Arsi.\n\n\nfatalities\nThe number of reported fatalities arising from an event. When there are conflicting reports, the most conservative estimate is recorded.\nE.g. 3No information on fatalities is recorded as 0 reported fatalities.\n\n\ntags\nAdditional structured information about the event. Separated by a semicolon.\nE.g. women targeted: politicians; sexual violence\n\n\ntimestamp\nAn automatically generated Unix timestamp that represents the exact date and time an event was uploaded to the ACLED API.\nE.g. 1676909320\n\n\n\n\n\n\n\n2.2.2 Myanmar Administrative Boundaries (Shapefiles):\nObtained through Geonode Mimu, this shapefile helps us to build the map and set the boundary zone of each district of myanmar. This dataset provides the geographical boundaries of Myanmar’s administrative divisions, from the national level down to the township level. It is essential for mapping conflict events to specific regions.\n\n\nCode to Import Shapefile Dataset\n\n\nStateDistrict\n\n\n\nM_State_Sf &lt;- st_read(dsn=\"data/raw/geospatial/stateLevel\", layer = \"mmr_polbnda_adm1_250k_mimu_1\") \n\nReading layer `mmr_polbnda_adm1_250k_mimu_1' from data source \n  `C:\\Users\\jiale\\Desktop\\IS415\\IS415-GAA\\Take_Home_Exercises\\Take_Home_Exercise_1\\data\\raw\\geospatial\\stateLevel' \n  using driver `ESRI Shapefile'\nSimple feature collection with 15 features and 6 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 92.1721 ymin: 9.696844 xmax: 101.17 ymax: 28.54554\nGeodetic CRS:  WGS 84\n\nM_State_Sf\n\nSimple feature collection with 15 features and 6 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 92.1721 ymin: 9.696844 xmax: 101.17 ymax: 28.54554\nGeodetic CRS:  WGS 84\nFirst 10 features:\n   OBJECTID          ST ST_PCODE           ST_RG          ST_MMR PCode_V\n1         1  Ayeyarwady   MMR017          Region  ဧရာဝတီတိုင်းဒေသကြီး     9.4\n2         2        Bago   MMR111          Region    ပဲခူးတိုင်းဒေသကြီး     9.4\n3         4        Chin   MMR004           State       ချင်းပြည်နယ်     9.4\n4         5      Kachin   MMR001           State       ကချင်ပြည်နယ်     9.4\n5         6       Kayah   MMR002           State       ကယားပြည်နယ်     9.4\n6         7       Kayin   MMR003           State        ကရင်ပြည်နယ်     9.4\n7         8      Magway   MMR009          Region   မကွေးတိုင်းဒေသကြီး     9.4\n8         9    Mandalay   MMR010          Region မန္တလေးတိုင်းဒေသကြီး     9.4\n9        10         Mon   MMR011           State         မွန်ပြည်နယ်     9.4\n10       11 Nay Pyi Taw   MMR018 Union Territory        နေပြည်တော်     9.4\n                         geometry\n1  MULTIPOLYGON (((95.20798 15...\n2  MULTIPOLYGON (((96.17964 19...\n3  MULTIPOLYGON (((93.36931 24...\n4  MULTIPOLYGON (((97.59674 28...\n5  MULTIPOLYGON (((97.1759 19....\n6  MULTIPOLYGON (((97.81508 16...\n7  MULTIPOLYGON (((94.11699 22...\n8  MULTIPOLYGON (((96.14023 23...\n9  MULTIPOLYGON (((97.73689 15...\n10 MULTIPOLYGON (((96.32013 20...\n\n\n\n\n\nM_District_Sf &lt;- st_read(dsn=\"data/raw/geospatial\", layer = \"mmr_polbnda_adm2_250k_mimu\") \n\nReading layer `mmr_polbnda_adm2_250k_mimu' from data source \n  `C:\\Users\\jiale\\Desktop\\IS415\\IS415-GAA\\Take_Home_Exercises\\Take_Home_Exercise_1\\data\\raw\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 80 features and 7 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 92.1721 ymin: 9.696844 xmax: 101.17 ymax: 28.54554\nGeodetic CRS:  WGS 84\n\nM_District_Sf\n\nSimple feature collection with 80 features and 7 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 92.1721 ymin: 9.696844 xmax: 101.17 ymax: 28.54554\nGeodetic CRS:  WGS 84\nFirst 10 features:\n   OBJECTID          ST ST_PCODE         DT   DT_PCODE      DT_MMR PCode_V\n1         1  Ayeyarwady   MMR017   Hinthada MMR017D002    ဟင်္သာတခရိုင်     9.4\n2         2  Ayeyarwady   MMR017    Labutta MMR017D004    လပွတ္တာခရိုင်     9.4\n3         3  Ayeyarwady   MMR017     Maubin MMR017D005     မအူပင်ခရိုင်     9.4\n4         4  Ayeyarwady   MMR017  Myaungmya MMR017D003 မြောင်းမြခရိုင်     9.4\n5         5  Ayeyarwady   MMR017    Pathein MMR017D001      ပုသိမ်ခရိုင်     9.4\n6         6  Ayeyarwady   MMR017     Pyapon MMR017D006     ဖျာပုံခရိုင်     9.4\n7         7 Bago (East)   MMR007       Bago MMR007D001      ပဲခူးခရိုင်     9.4\n8         8 Bago (East)   MMR007    Taungoo MMR007D002    တောင်ငူခရိုင်     9.4\n9         9 Bago (West)   MMR008       Pyay MMR008D001      ပြည်ခရိုင်     9.4\n10       10 Bago (West)   MMR008 Thayarwady MMR008D002   သာယာဝတီခရိုင်     9.4\n                         geometry\n1  MULTIPOLYGON (((95.12637 18...\n2  MULTIPOLYGON (((95.04462 15...\n3  MULTIPOLYGON (((95.38231 17...\n4  MULTIPOLYGON (((94.6942 16....\n5  MULTIPOLYGON (((94.27572 15...\n6  MULTIPOLYGON (((95.20798 15...\n7  MULTIPOLYGON (((95.90674 18...\n8  MULTIPOLYGON (((96.17964 19...\n9  MULTIPOLYGON (((95.70458 19...\n10 MULTIPOLYGON (((95.85173 18...\n\n\n\n\n\n\n\n2.2.2.1 Understanding the data set fields.\n\n\n\n\n\n\n\nField Name\nDescription\n\n\nOBJECTID\nThis is a unique identifier for each feature in the dataset, typically used to identify individual records or polygons in the shapefile.\n\n\nST\nThis represents the State or Region in Myanmar. For example, in your dataset, “Ayeyarwady” refers to a state/region.\n\n\nST_PCODE\nThis stands for State Postal Code. It is a standardized code that represents each state or region in Myanmar, such as “MMR017” for Ayeyarwady.\n\n\nDT\nThis stands for District or Township within the respective state/region. For example, “Hinthada” is a district or township within Ayeyarwady.\n\n\nDT_PCODE\nThis stands for District/Township Postal Code. It is a standardized postal code for each district or township, such as “MMR017D002” for the Hinthada district/township in Ayeyarwady.\n\n\nDT_MMR\nThis field could be the District/Township name in Myanmar script, written in the local language. It may be an alternative representation of the “DT” field, showing the name of the district/township in Myanmar’s native language.\n\n\nPCODE_V\nThis could be a Version of the Postal Code or a verification value used internally in the dataset. In this case, the value is “9.4”, possibly indicating a specific version of postal codes or an accuracy measure.\n\n\ngeometry\nThis column represents the spatial data for each district/township. It contains the geometrical shape (MULTIPOLYGON) defining the boundaries of the state or district/township, with coordinates provided in longitude and latitude."
  },
  {
    "objectID": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#myanmar-shapefile",
    "href": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#myanmar-shapefile",
    "title": "Take_Home Exercise 1: Geospatial Analytics for Social Good: Application of Spatial and Spatio-temporal Point Patterns Analysis to discover the geographical distribution of Armed Conflict in Myanmar",
    "section": "3.1 Myanmar Shapefile",
    "text": "3.1 Myanmar Shapefile\n\n3.1.1 Setting the CRS for the\nSince Myanmar uses CRS of 32647 and when we download the map it’s in WGS84, we should change it to 32647 .\n\nStateDistrict\n\n\n\nst_crs(M_State_Sf)\n\nCoordinate Reference System:\n  User input: WGS 84 \n  wkt:\nGEOGCRS[\"WGS 84\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"latitude\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"longitude\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    ID[\"EPSG\",4326]]\n\n# Set the CRS for m_sf, assuming the appropriate CRS is WGS 84 (EPSG:32647)\nM_State_Sf &lt;- st_transform(M_State_Sf, crs = 32647)\n# Verify that the CRS has been correctly set\nprint(st_crs(M_State_Sf))\n\nCoordinate Reference System:\n  User input: EPSG:32647 \n  wkt:\nPROJCRS[\"WGS 84 / UTM zone 47N\",\n    BASEGEOGCRS[\"WGS 84\",\n        ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n            MEMBER[\"World Geodetic System 1984 (Transit)\"],\n            MEMBER[\"World Geodetic System 1984 (G730)\"],\n            MEMBER[\"World Geodetic System 1984 (G873)\"],\n            MEMBER[\"World Geodetic System 1984 (G1150)\"],\n            MEMBER[\"World Geodetic System 1984 (G1674)\"],\n            MEMBER[\"World Geodetic System 1984 (G1762)\"],\n            MEMBER[\"World Geodetic System 1984 (G2139)\"],\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ENSEMBLEACCURACY[2.0]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4326]],\n    CONVERSION[\"UTM zone 47N\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",99,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",0.9996,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",500000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Navigation and medium accuracy spatial referencing.\"],\n        AREA[\"Between 96°E and 102°E, northern hemisphere between equator and 84°N, onshore and offshore. China. Indonesia. Laos. Malaysia - West Malaysia. Mongolia. Myanmar (Burma). Russian Federation. Thailand.\"],\n        BBOX[0,96,84,102]],\n    ID[\"EPSG\",32647]]\n\n\n\n\n\nst_crs(M_District_Sf)\n\nCoordinate Reference System:\n  User input: WGS 84 \n  wkt:\nGEOGCRS[\"WGS 84\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"latitude\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"longitude\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    ID[\"EPSG\",4326]]\n\n# Set the CRS for m_sf, assuming the appropriate CRS is WGS 84 (EPSG:32647)\nM_District_Sf &lt;- st_transform(M_District_Sf, crs = 32647)\n# Verify that the CRS has been correctly set\nprint(st_crs(M_District_Sf))\n\nCoordinate Reference System:\n  User input: EPSG:32647 \n  wkt:\nPROJCRS[\"WGS 84 / UTM zone 47N\",\n    BASEGEOGCRS[\"WGS 84\",\n        ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n            MEMBER[\"World Geodetic System 1984 (Transit)\"],\n            MEMBER[\"World Geodetic System 1984 (G730)\"],\n            MEMBER[\"World Geodetic System 1984 (G873)\"],\n            MEMBER[\"World Geodetic System 1984 (G1150)\"],\n            MEMBER[\"World Geodetic System 1984 (G1674)\"],\n            MEMBER[\"World Geodetic System 1984 (G1762)\"],\n            MEMBER[\"World Geodetic System 1984 (G2139)\"],\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ENSEMBLEACCURACY[2.0]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4326]],\n    CONVERSION[\"UTM zone 47N\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",99,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",0.9996,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",500000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Navigation and medium accuracy spatial referencing.\"],\n        AREA[\"Between 96°E and 102°E, northern hemisphere between equator and 84°N, onshore and offshore. China. Indonesia. Laos. Malaysia - West Malaysia. Mongolia. Myanmar (Burma). Russian Federation. Thailand.\"],\n        BBOX[0,96,84,102]],\n    ID[\"EPSG\",32647]]\n\n\n\n\n\n\n\n3.1.2 Renaming and removal of column names\n\nStateDistrict\n\n\n\ncolnames(M_State_Sf) &lt;- c(\"OBJECTID\", \"state\",\"state_code\",\"type\", \"state_myr\", \"mimi_version\", \"geometry\")\n\nM_State_Sf_Cleansed &lt;- M_State_Sf %&gt;% select(state, type, state_myr ,geometry)\n\n\n\n\ncolnames(M_District_Sf) &lt;- c(\"OBJECTID\", \"state\", \"state_code\", \"district\", \"district_code\", \"district_mmr\", \"mimi_version\", \"geometry\")\n\nM_District_Sf_Cleansed &lt;- M_District_Sf %&gt;% select(state, district, district_mmr, geometry)\n\n\n\n\n\n\n3.1.3 Checking for validity of data\nWhen working with spatial data, it’s crucial to ensure that all geometries are valid. Invalid geometries can cause errors in analysis and visualization.\n\nChecking Validity with st_is_valid():\nIdentifying Invalid Geometries:\nFixing Invalid Geometries with st_make_valid()\n\n\nStateDistrict\n\n\n\n#checking if it's valid\nM_State_Sf_Validity &lt;- st_is_valid(M_State_Sf_Cleansed)\nM_State_Sf_Invalid &lt;- which(!M_State_Sf_Validity)\nif (length(M_State_Sf_Invalid) &gt; 0) {\n  print(\"MPZ Invalid!\")\n  print(M_State_Sf_cleansed[M_State_Sf_Invalid, ])\n} else {\n  print(\"it's valid!\")\n}\n\n[1] \"it's valid!\"\n\n\n\n\n\n#checking if it's valid\nM_District_Sf_Validity &lt;- st_is_valid(M_District_Sf_Cleansed)\nM_District_Sf_Invalid &lt;- which(!M_District_Sf_Validity)\nif (length(M_District_Sf_Invalid) &gt; 0) {\n  print(\"MPZ Invalid!\")\n  print(M_District_Sf_cleansed[M_District_Sf_Invalid, ])\n} else {\n  print(\"it's valid!\")\n}\n\n[1] \"it's valid!\"\n\n\n\n\n\n\n\n3.1.4 Visualizing the mynamar map\nOn the top right, you can toggle between the district level and also the state level to understand more about the boundaries of Myanmar.\n\nStateDistrict\n\n\n\ntm_shape(M_State_Sf_Cleansed) +  # Base map (Myanmar boundaries)\n  tm_basemap(server = \"OpenStreetMap.HOT\") +  # Add OpenStreetMap as the basemap\n  tm_polygons(\"state\",  # Color the base map by state\n              palette = \"Set3\",  # Use Set3 color palette for states\n              border.col = \"gray\",  # Border color for the states\n              alpha = 0.5,  # Semi-transparent polygons\n              title = \"State\",  # Legend title for states\n              legend.show = TRUE  # Show legend for state colors\n             ) +\n  tm_layout(main.title = \"States of Myanmar\",  # Main map title\n            legend.outside = TRUE)  # Position the legend outside the map\n\n\n\n\n\n\n\n\n\n\nThere is more than 80 district here, so it only showcases 30 :)\n\ntm_shape(M_District_Sf_Cleansed) +  # Base map (Myanmar boundaries)\n  tm_basemap(server = \"OpenStreetMap.HOT\") +  # Add OpenStreetMap as the basemap\n  tm_polygons(\"district\",  # Color the base map by state\n              palette = \"Set3\",  # Use Set3 color palette for states\n              border.col = \"gray\",  # Border color for the states\n              alpha = 0.5,  # Semi-transparent polygons\n              title = \"District\",  # Legend title for states\n              legend.show = TRUE  # Show legend for state colors\n             ) +\n  tm_layout(main.title = \"District of Myanmar\",  # Main map title\n            legend.outside = TRUE)  # Position the legend outside the map\n\nWarning: Number of levels of the variable \"district\" is 80, which is larger\nthan max.categories (which is 30), so levels are combined. Set\ntmap_options(max.categories = 80) in the layer function to show all levels.\n\n\nSome legend labels were too wide. These labels have been resized to 0.51, 0.48, 0.53, 0.52, 0.49. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger."
  },
  {
    "objectID": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#acled-data",
    "href": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#acled-data",
    "title": "Take_Home Exercise 1: Geospatial Analytics for Social Good: Application of Spatial and Spatio-temporal Point Patterns Analysis to discover the geographical distribution of Armed Conflict in Myanmar",
    "section": "3.2 ACLED Data",
    "text": "3.2 ACLED Data\n\n3.2.1 Changing the Column Names\nSince Myanmar’s regional hierarchy follows State, District, and Township levels, we will rename the columns accordingly:\n\nadmin1 → State\nadmin2 → District\nadmin3 → Township\n\nThis is important because different countries use different administrative hierarchies. For example, in Singapore, the hierarchy is organized by Region and Subzones. Adjusting these names ensures that our dataset aligns with Myanmar’s specific regional structure for accurate analysis.\n\nACLEDData_Cleanse &lt;- ACLEDData %&gt;%\n  select(event_id_cnty, event_date, year, disorder_type, event_type, actor1, inter1, \n         actor2, inter2, interaction, admin1, admin2, admin3, location, latitude, \n         longitude, fatalities) %&gt;%\n  rename(state = admin1, district = admin2, township = admin3) %&gt;%\n  mutate(across(where(is.character), ~ replace_na(.x, \"NA\")),  # Replace NA in character columns with \"NA\"\n         across(where(is.numeric), ~ replace_na(.x, 0)))  # Replace NA in numeric columns with 0\n\n\n\n3.2.2 Adding a “Quarter-Year” Column\nTo facilitate our temporal analysis, we need to add a “quarter-year” column based on the event_date field. This can be done by adjusting the date format to represent the quarter and year, ensuring that each event is categorized by the specific quarter it occurred in (e.g., Q1-2021, Q2-2022). This will allow for easier analysis of conflict trends over time.\n\n# Convert event_date to Date format (if it's not already a date)\nACLEDData_Cleanse$event_date &lt;- as.Date(ACLEDData_Cleanse$event_date, format=\"%d-%b-%y\")  # Adjust the format if needed\n# Add a new column that shows the quarter and year\nACLEDData_Cleanse &lt;- ACLEDData_Cleanse %&gt;%\n  mutate(quarter_year = paste0(\"Q\", quarter(event_date), \"-\", year(event_date)))\n\nhead(ACLEDData_Cleanse)\n\n# A tibble: 6 × 18\n  event_id_cnty event_date  year disorder_type   event_type actor1 inter1 actor2\n  &lt;chr&gt;         &lt;date&gt;     &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;      &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt; \n1 MMR64313      2024-06-30  2024 Political viol… Battles    Peopl…      3 Milit…\n2 MMR64320      2024-06-30  2024 Political viol… Battles    Peopl…      3 Milit…\n3 MMR64321      2024-06-30  2024 Political viol… Battles    Peopl…      3 Milit…\n4 MMR64322      2024-06-30  2024 Strategic deve… Strategic… Milit…      1 NA    \n5 MMR64323      2024-06-30  2024 Political viol… Battles    PKDF …      3 Milit…\n6 MMR64324      2024-06-30  2024 Strategic deve… Strategic… Milit…      1 NA    \n# ℹ 10 more variables: inter2 &lt;dbl&gt;, interaction &lt;dbl&gt;, state &lt;chr&gt;,\n#   district &lt;chr&gt;, township &lt;chr&gt;, location &lt;chr&gt;, latitude &lt;dbl&gt;,\n#   longitude &lt;dbl&gt;, fatalities &lt;dbl&gt;, quarter_year &lt;chr&gt;\n\n\n\n\n3.2.3 Joining ACLED’s Codebook Description\nACLED’s stores their data for the column “interaction” and “inter1” and “inter2” in codes, using their code book, let’s reorganise their data for simplier view, we can reference the code book here to know what each code represent. Map it out as a csv file read it in and change accordingly.\n\n3.2.3.1 Left joining inter1 and inter’s description.\nFor more details about each inter code read here.\n\nACLEDActorInterCode &lt;- read_csv(\"data/raw/aspatial/ActorTypesInterCode.csv\")\n\nRows: 8 Columns: 2\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): Description\ndbl (1): code\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nACLEDData_Cleanse &lt;- ACLEDData_Cleanse %&gt;%\n  left_join(ACLEDActorInterCode, by = c(\"inter1\" = \"code\")) %&gt;%\n  rename(inter1_description = Description)\n# Left join again for inter2\nACLEDData_Cleanse &lt;- ACLEDData_Cleanse %&gt;%\n  left_join(ACLEDActorInterCode, by = c(\"inter2\" = \"code\")) %&gt;%\n  rename(inter2_description = Description)\n\nhead(ACLEDData_Cleanse)\n\n# A tibble: 6 × 20\n  event_id_cnty event_date  year disorder_type   event_type actor1 inter1 actor2\n  &lt;chr&gt;         &lt;date&gt;     &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;      &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt; \n1 MMR64313      2024-06-30  2024 Political viol… Battles    Peopl…      3 Milit…\n2 MMR64320      2024-06-30  2024 Political viol… Battles    Peopl…      3 Milit…\n3 MMR64321      2024-06-30  2024 Political viol… Battles    Peopl…      3 Milit…\n4 MMR64322      2024-06-30  2024 Strategic deve… Strategic… Milit…      1 NA    \n5 MMR64323      2024-06-30  2024 Political viol… Battles    PKDF …      3 Milit…\n6 MMR64324      2024-06-30  2024 Strategic deve… Strategic… Milit…      1 NA    \n# ℹ 12 more variables: inter2 &lt;dbl&gt;, interaction &lt;dbl&gt;, state &lt;chr&gt;,\n#   district &lt;chr&gt;, township &lt;chr&gt;, location &lt;chr&gt;, latitude &lt;dbl&gt;,\n#   longitude &lt;dbl&gt;, fatalities &lt;dbl&gt;, quarter_year &lt;chr&gt;,\n#   inter1_description &lt;chr&gt;, inter2_description &lt;chr&gt;\n\n\n\n\n3.2.3.2 Left joining interaction description.\nFor more details about each interaction code read here.\n\nACLEDInteractionCode &lt;- read_csv(\"data/raw/aspatial/AcledInteractionCodes.csv\")\n\nRows: 44 Columns: 2\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): Description\ndbl (1): code\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nACLEDData_Cleanse &lt;- ACLEDData_Cleanse %&gt;%\n  left_join(ACLEDInteractionCode, by = c(\"interaction\" = \"code\")) %&gt;%\n  rename(interaction_description = Description)\nhead(ACLEDData_Cleanse)\n\n# A tibble: 6 × 21\n  event_id_cnty event_date  year disorder_type   event_type actor1 inter1 actor2\n  &lt;chr&gt;         &lt;date&gt;     &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;      &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt; \n1 MMR64313      2024-06-30  2024 Political viol… Battles    Peopl…      3 Milit…\n2 MMR64320      2024-06-30  2024 Political viol… Battles    Peopl…      3 Milit…\n3 MMR64321      2024-06-30  2024 Political viol… Battles    Peopl…      3 Milit…\n4 MMR64322      2024-06-30  2024 Strategic deve… Strategic… Milit…      1 NA    \n5 MMR64323      2024-06-30  2024 Political viol… Battles    PKDF …      3 Milit…\n6 MMR64324      2024-06-30  2024 Strategic deve… Strategic… Milit…      1 NA    \n# ℹ 13 more variables: inter2 &lt;dbl&gt;, interaction &lt;dbl&gt;, state &lt;chr&gt;,\n#   district &lt;chr&gt;, township &lt;chr&gt;, location &lt;chr&gt;, latitude &lt;dbl&gt;,\n#   longitude &lt;dbl&gt;, fatalities &lt;dbl&gt;, quarter_year &lt;chr&gt;,\n#   inter1_description &lt;chr&gt;, inter2_description &lt;chr&gt;,\n#   interaction_description &lt;chr&gt;\n\n\n\n\n\n3.2.3 Making it a SF Object and reverse geolocate state and district\nSince ACLED provides longitude and latitude data, I prefer to reverse geolocate the points to match Myanmar’s official state and district boundaries. We are uncertain how ACLED assigns these regions, so to ensure consistency, we remove the original state and district columns from the ACLED data and replace them with the geolocated values.\nSteps:\n\nConvert ACLED Data to an SF Object: Using longitude and latitude coordinates, transform the ACLED dataset into a spatial object. Remember thatt we have to set CRS 32647 here as well.\nPerform a Spatial Join: Match the points from ACLED with the corresponding state and district boundaries from the m_sf shapefile, selecting only those columns.\nRemove Original Columns: After the spatial join, drop the original state, district, and township columns from the ACLED dataset.\nRename the Joined Columns: Rename the newly joined state.y and district.y to state and district, effectively replacing the original columns with the reverse-geolocated values.\n\n\n# Step 1: Convert ACLEDDataCleanse to an sf object using longitude and latitude\nACLEDData_Cleanse_Sf &lt;- st_as_sf(ACLEDData_Cleanse, coords = c(\"longitude\", \"latitude\"), crs = 4326, remove = FALSE)\n\n# Step 2: Transform ACLEDDataCleanse_sf to the same CRS as m_sf (EPSG: 32647)\nACLEDData_Cleanse_Sf &lt;- st_transform(ACLEDData_Cleanse_Sf, crs = 32647)\n\n# Step 3: Perform a spatial join, selecting only the state and district from m_sf\nreverse_geolocated_state &lt;- st_join(ACLEDData_Cleanse_Sf, M_State_Sf_Cleansed[, c(\"state\")], join = st_intersects)\n\n# Step 2: Spatial join to add 'district' from M_District_Sf_Cleansed\nreverse_geolocated_district &lt;- st_join(reverse_geolocated_state, M_District_Sf_Cleansed[, c(\"district\")], join = st_intersects)\n\n# Step 3: Remove original 'state', 'district', and 'township' columns from ACLEDData_Cleanse (if they exist)\n# This step removes the original columns, and then renames the newly joined columns\nACLEDData_Cleanse_Sf &lt;- reverse_geolocated_district %&gt;%\n  select(-contains(\"state.x\"), -contains(\"district.x\"), -contains(\"township\")) %&gt;%  # Remove old state, district, township columns\n  rename(state = state.y, district = district.y)  # Rename newly joined columns\n\nACLEDData_Cleanse &lt;- st_drop_geometry(ACLEDData_Cleanse_Sf)\n\n# View the updated data\nprint(ACLEDData_Cleanse_Sf)\n\nSimple feature collection with 42608 features and 20 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -208804.4 ymin: 1103500 xmax: 640934.5 ymax: 3042960\nProjected CRS: WGS 84 / UTM zone 47N\n# A tibble: 42,608 × 21\n   event_id_cnty event_date  year disorder_type  event_type actor1 inter1 actor2\n   &lt;chr&gt;         &lt;date&gt;     &lt;dbl&gt; &lt;chr&gt;          &lt;chr&gt;      &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt; \n 1 MMR64313      2024-06-30  2024 Political vio… Battles    Peopl…      3 Milit…\n 2 MMR64320      2024-06-30  2024 Political vio… Battles    Peopl…      3 Milit…\n 3 MMR64321      2024-06-30  2024 Political vio… Battles    Peopl…      3 Milit…\n 4 MMR64322      2024-06-30  2024 Strategic dev… Strategic… Milit…      1 NA    \n 5 MMR64323      2024-06-30  2024 Political vio… Battles    PKDF …      3 Milit…\n 6 MMR64324      2024-06-30  2024 Strategic dev… Strategic… Milit…      1 NA    \n 7 MMR64325      2024-06-30  2024 Political vio… Battles    Milit…      1 PSLF/…\n 8 MMR64326      2024-06-30  2024 Political vio… Battles    PSLF/…      2 Milit…\n 9 MMR64328      2024-06-30  2024 Political vio… Battles    Milit…      1 PSLF/…\n10 MMR64330      2024-06-30  2024 Political vio… Battles    Milit…      1 PSLF/…\n# ℹ 42,598 more rows\n# ℹ 13 more variables: inter2 &lt;dbl&gt;, interaction &lt;dbl&gt;, location &lt;chr&gt;,\n#   latitude &lt;dbl&gt;, longitude &lt;dbl&gt;, fatalities &lt;dbl&gt;, quarter_year &lt;chr&gt;,\n#   inter1_description &lt;chr&gt;, inter2_description &lt;chr&gt;,\n#   interaction_description &lt;chr&gt;, geometry &lt;POINT [m]&gt;, state &lt;chr&gt;,\n#   district &lt;chr&gt;\n\n\n\n\n3.2.5 Visualizing it by Event Type\n\n# Set tmap mode to plot for static maps\ntmap_mode(\"view\")\n\ntmap mode set to interactive viewing\n\n# Create the tmap object with the base map and event markers\ntm_basemap(server = \"OpenStreetMap\") +  # Add OpenStreetMap as the base map\n  \n  # Add Myanmar state boundaries with transparency\n  tm_shape(M_State_Sf_Cleansed) + \n  tm_polygons(\"state\", alpha = 0.3, border.col = \"gray\", \n              title = \"State Boundaries\", legend.show = TRUE) +  # Add a legend for state boundaries\n  \n  # Add event markers (bubbles) with size based on fatalities\n  tm_shape(ACLEDData_Cleanse_Sf) + \n  tm_bubbles(size = \"fatalities\",  # Marker size based on fatalities\n             col = \"event_type\",  # Color markers by event type\n             palette = \"Set1\",  # Use Set1 color palette for event types\n             border.col = \"black\",  # Border color for bubbles\n             border.alpha = 0.5,  # Semi-transparent border\n             title.size = \"Number of Fatalities\",  # Title for bubble size legend\n             title.col = \"Event Types\",  # Title for event type legend\n             legend.size.show = TRUE,  # Show legend for bubble size\n             legend.col.show = TRUE) +  # Show legend for event types\n  \n  # Layout settings for the map, including title and legend positioning\n  tm_layout(main.title = \"Myanmar's State Conflicts by Fatalities\",  # Main map title\n            main.title.size = 1.5,  # Title font size\n            legend.outside = TRUE,  # Position legend outside the map\n            legend.outside.size = 0.5,  # Adjust size of outside legend\n            legend.position = c(\"left\", \"top\"),  # Position for the event type legend\n            legend.title.size = 1.2,  # Size of the legend title\n            legend.text.size = 1,  # Size of the legend text\n            legend.bg.color = \"white\",  # Background color for the legend\n            legend.bg.alpha = 0.5,  # Transparency for the legend background\n            inner.margins = c(0.05, 0.05, 0.05, 0.05))  # Inner margins for the map\n\nlegend.postion is used for plot mode. Use view.legend.position in tm_view to set the legend position in view mode.\n\n\nLegend for symbol sizes not available in view mode."
  },
  {
    "objectID": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#aggregation-of-data-for-exploratory-purposes",
    "href": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#aggregation-of-data-for-exploratory-purposes",
    "title": "Take_Home Exercise 1: Geospatial Analytics for Social Good: Application of Spatial and Spatio-temporal Point Patterns Analysis to discover the geographical distribution of Armed Conflict in Myanmar",
    "section": "4.1 Aggregation of Data for exploratory purposes",
    "text": "4.1 Aggregation of Data for exploratory purposes\nStep 1: Filter Data for Civilians\nIn this first step, the data (ACLEDData_Cleanse) is filtered so that only rows where either “Civilians” are involved in the conflict (inter1_description or inter2_description) are kept. Additionally, rows where the state information is missing (NA) are removed because these conflicts can’t be assigned to a specific geographical area.\n\nfiltered_data &lt;- ACLEDData_Cleanse %&gt;%\n  filter((inter1_description == \"Civilians\" | inter2_description == \"Civilians\") & !is.na(state))\n\nStep 2: Calculate State Area in Square Kilometers\nNext, the code calculates the area for each state from the M_State_Sf_Cleansed spatial dataset. The st_area function retrieves the area in square meters, and dividing by 1 million (1e6) converts it into square kilometers. This information will be used later to calculate conflict and fatality density.\n\nstate_area_km2 &lt;- st_area(M_State_Sf_Cleansed) / 1e6\nstate_area_df &lt;- data.frame(state = M_State_Sf_Cleansed$state, area_km2 = as.numeric(state_area_km2))\n\nStep 3: Aggregate Total Conflicts and Fatalities by State\nThe next step is to group the filtered data by state and calculate two key metrics: the total number of conflicts and the total number of fatalities for each state. This is done using group_by and summarise.\n\nagg_data_by_state &lt;- filtered_data %&gt;%\n  group_by(state) %&gt;%\n  summarise(\n    total_conflicts = n(), \n    total_fatalities = sum(fatalities, na.rm = TRUE), \n    .groups = \"drop\"\n  )\n\nStep 4: Convert to Non-Spatial Data Frame\nHere, the spatial data is converted into a regular data frame by dropping the geometry information. This allows easier manipulation of the non-spatial data for further processing.\n\nfiltered_data_df &lt;- st_drop_geometry(filtered_data)\n\nStep 5: Prepare Data Frame for Yearly Data\nTo store yearly conflict and fatality data for each state, an empty data frame is initialized by selecting distinct states from the filtered data\n\nfinal_result &lt;- filtered_data_df %&gt;% select(state) %&gt;% distinct()\n\nStep 6: Loop Through Each Year and Calculate Yearly Conflicts/Fatalities\nIn this step, the code iterates over each unique year in the dataset. For each year, it calculates the total conflicts and fatalities for each state. The results are merged back into the final_result data frame, with columns named according to the year (e.g., conflicts_2021, fatalities_2021).\n\nunique_years &lt;- unique(filtered_data_df$year)\n\nfor (yr in unique_years) {\n  yearly_data &lt;- filtered_data_df %&gt;%\n    filter(year == yr) %&gt;%\n    group_by(state) %&gt;%\n    summarise(\n      conflicts = n(), \n      fatalities = sum(fatalities, na.rm = TRUE)\n    ) %&gt;%\n    rename_at(vars(conflicts, fatalities), ~ paste0(., \"_\", yr))  # Rename with year\n  \n  final_result &lt;- left_join(final_result, yearly_data, by = \"state\")\n}\n\nStep 7: Replace NAs with 0\nAny missing data for a state-year combination (e.g., a state with no conflicts in a particular year) is replaced with 0 to avoid leaving gaps in the analysis.\n\nfinal_result &lt;- final_result %&gt;%\n  mutate(across(everything(), ~ ifelse(is.na(.), 0, .)))\n\nStep 8: Calculate Conflict and Fatality Density\nNow, the code calculates the density of conflicts and fatalities per square kilometer for each state. The results from Step 3 (agg_data_by_state) are joined with the state area data from Step 2. The density is simply the number of conflicts or fatalities divided by the area in square kilometers.\n\nagg_data_with_density &lt;- agg_data_by_state %&gt;%\n  left_join(state_area_df, by = \"state\") %&gt;%\n  mutate(\n    conflict_density = total_conflicts / area_km2,\n    fatality_density = total_fatalities / area_km2\n  )\n\nStep 9: Merge Yearly Data and Density with Spatial Data\nFinally, the spatial data (M_State_Sf_Cleansed) is merged with the yearly conflict/fatality data (final_result) and the density data (agg_data_with_density). Additional calculations are made to find the fatality-per-conflict ratio which are then added to the final spatial dataset.\n\nfinalized_map &lt;- M_State_Sf_Cleansed %&gt;%\n  left_join(final_result, by = \"state\") %&gt;%\n  left_join(agg_data_with_density, by = \"state\")\n\nfinalized_map &lt;- finalized_map %&gt;%\n  mutate(conflict_fatality_ratio = ifelse(total_fatalities == 0, NA, total_fatalities / total_conflicts))\n\nfinalized_map &lt;- finalized_map %&gt;%\n  mutate(\n    fatality_per_conflict = ifelse(total_conflicts == 0, NA, total_fatalities / total_conflicts),\n  )\n\nfinalized_map &lt;- finalized_map %&gt;%\n  mutate(\n    rank_total_conflicts = rank(-total_conflicts, ties.method = \"min\"),  # Rank total_conflicts (largest to smallest)\n    rank_total_fatalities = rank(-total_fatalities, ties.method = \"min\"),  # Rank total_fatalities (largest to smallest)\n    rank_conflict_density = rank(-conflict_density, ties.method = \"min\"),  # Rank conflict_density (largest to smallest)\n    rank_fatality_density = rank(-fatality_density, ties.method = \"min\"),  # Rank fatality_density (largest to smallest)\n    rank_fatality_per_conflict = rank(-fatality_per_conflict, ties.method = \"min\")  # Rank fatality_per_conflict (largest to smallest)\n  )\n\nFinal Output: Display the Data\nThe finalized_map contains all the processed information, including conflict/fatality counts, densities, and state geometry, which can now be visualized or further analyzed.\n\nhead(finalized_map)\n\nSimple feature collection with 6 features and 23 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -162806.6 ymin: 1682875 xmax: 491639.1 ymax: 3158467\nProjected CRS: WGS 84 / UTM zone 47N\n       state   type      state_myr conflicts_2024 fatalities_2024\n1 Ayeyarwady Region ဧရာဝတီတိုင်းဒေသကြီး             64               9\n2       Bago Region   ပဲခူးတိုင်းဒေသကြီး            194             128\n3       Chin  State      ချင်းပြည်နယ်             72              52\n4     Kachin  State      ကချင်ပြည်နယ်            160              95\n5      Kayah  State      ကယားပြည်နယ်             21              38\n6      Kayin  State       ကရင်ပြည်နယ်             52              59\n  conflicts_2023 fatalities_2023 conflicts_2022 fatalities_2022 conflicts_2021\n1             83               7            177              29            233\n2            339             220            172              61            191\n3            101              76            204              80            160\n4            316             133            226             140            221\n5            113              74            149              87            114\n6            165              83            165              86            116\n  fatalities_2021 total_conflicts total_fatalities area_km2 conflict_density\n1              34             557               79 33738.82       0.01650917\n2              87             896              496 38556.99       0.02323833\n3              32             537              240 36276.56       0.01480295\n4              71             923              439 88977.32       0.01037343\n5             108             397              307 11763.10       0.03374961\n6              57             498              285 30337.59       0.01641528\n  fatality_density                       geometry conflict_fatality_ratio\n1      0.002341516 MULTIPOLYGON (((93411.72 17...               0.1418312\n2      0.012864076 MULTIPOLYGON (((203949.9 21...               0.5535714\n3      0.006615843 MULTIPOLYGON (((-72918.03 2...               0.4469274\n4      0.004933841 MULTIPOLYGON (((362696.3 31...               0.4756230\n5      0.026098563 MULTIPOLYGON (((309155.7 22...               0.7732997\n6      0.009394287 MULTIPOLYGON (((373551.3 18...               0.5722892\n  fatality_per_conflict rank_total_conflicts rank_total_fatalities\n1             0.1418312                   11                    14\n2             0.5535714                    9                     6\n3             0.4469274                   12                    13\n4             0.4756230                    8                     7\n5             0.7732997                   14                    10\n6             0.5722892                   13                    12\n  rank_conflict_density rank_fatality_density rank_fatality_per_conflict\n1                    10                    15                         15\n2                     9                     8                          4\n3                    12                    11                          9\n4                    15                    13                          6\n5                     6                     4                          1\n6                    11                    10                          3\n\n\n\n4.2 Visualizing the aggregated data.\nFor each column that we created earlier, we can now showcase it in a choropleth map to highlight the states with the highest values in each category. These maps will help visually identify which state has the highest value for each column. You can navigate through the tabset to explore the different metrics and easily view the data on a map!\n\nTotal Civilian ConflictsTotal Fatalities for civilians related conflicts.Civilian Conflict DensityFatality DensityFatality Per Civilian Conflict\n\n\n\n# Create the tmap object for total civilian conflicts\ntm_total_conflicts &lt;- \n  # Layer for total civilian conflicts\n  tm_shape(finalized_map) +\n  tm_polygons(\"total_conflicts\", \n              title = \"Total Civilian Related Conflicts\",\n              palette = \"Reds\", \n              border.col = \"black\", \n              alpha = 0.8,  # Transparency for polygons\n              border.alpha = 0.5,  # Semi-transparent border\n              id = \"state\") +  # Set state as identifier for the polygons\n\n  # Layout settings matching your style\n  tm_layout(\n    main.title = \"Myanmar's State by Total Civilian Related Conflicts\",  # Main map title\n    main.title.size = 1.0,  # Title font size\n    legend.outside = TRUE,  # Position legend outside the map\n    legend.outside.size = 0.5,  # Adjust size of outside legend\n    legend.position = c(\"left\", \"top\"),  # Position for the event type legend\n    legend.title.size = 1.2,  # Size of the legend title\n    legend.text.size = 1,  # Size of the legend text\n    legend.bg.color = \"white\",  # Background color for the legend\n    legend.bg.alpha = 0.5,  # Transparency for the legend background\n    inner.margins = c(0.05, 0.05, 0.05, 0.05)  # Set inner margins for better spacing\n  )\ntm_total_conflicts\n\n\n\n\n\n\n\n\n\n\n\n# Create the tmap object for total civilian conflicts\ntm_total_fatalities &lt;- tm_basemap(server = c(\"Esri.WorldGrayCanvas\", \"OpenStreetMap\", \"Esri.WorldTopoMap\")) +\n  # Layer for total civilian conflicts\n  tm_shape(finalized_map) +\n  tm_polygons(\"total_fatalities\", \n              title = \"Total Fatalities by Civilian Related Conflicts\",\n              palette = \"Blues\", \n              border.col = \"black\", \n              alpha = 0.8,  # Transparency for polygons\n              border.alpha = 0.5,  # Semi-transparent border\n              id = \"state\") +  # Set state as identifier for the polygons\n\n  # Layout settings matching your style\n  tm_layout(\n    main.title = \"Myanmar's State by Total Fatatlies For Civilian Related Conflicts\",  # Main map title\n    main.title.size = 1.0,  # Title font size\n    legend.outside = TRUE,  # Position legend outside the map\n    legend.outside.size = 0.5,  # Adjust size of outside legend\n    legend.position = c(\"left\", \"top\"),  # Position for the event type legend\n    legend.title.size = 1.2,  # Size of the legend title\n    legend.text.size = 1,  # Size of the legend text\n    legend.bg.color = \"white\",  # Background color for the legend\n    legend.bg.alpha = 0.5,  # Transparency for the legend background\n    inner.margins = c(0.05, 0.05, 0.05, 0.05)  # Set inner margins for better spacing\n  )\n\ntm_total_fatalities\n\n\n\n\n\n\n\n\n\n\n\ntm_conflict_density &lt;-\n  # Layer for total civilian conflicts\n  tm_shape(finalized_map) +\n  tm_polygons(\"conflict_density\", \n              title = \"Myanmar State by Civilian Related Conflicts Density\",\n              palette = \"Blues\", \n              border.col = \"black\", \n              alpha = 0.8,  # Transparency for polygons\n              border.alpha = 0.5,  # Semi-transparent border\n              id = \"state\") +  # Set state as identifier for the polygons\n\n  # Layout settings matching your style\n  tm_layout(\n    main.title = \"Myanmar State by Civilian Related Conflicts Density\",  # Main map title\n    main.title.size = 1.0,  # Title font size\n    legend.outside = TRUE,  # Position legend outside the map\n    legend.outside.size = 0.5,  # Adjust size of outside legend\n    legend.position = c(\"left\", \"top\"),  # Position for the event type legend\n    legend.title.size = 1.2,  # Size of the legend title\n    legend.text.size = 1,  # Size of the legend text\n    legend.bg.color = \"white\",  # Background color for the legend\n    legend.bg.alpha = 0.5,  # Transparency for the legend background\n    inner.margins = c(0.05, 0.05, 0.05, 0.05)  # Set inner margins for better spacing\n  )\n\ntm_conflict_density\n\n\n\n\n\n\n\n\n\n\n\ntm_fatalities_conflict &lt;- \n  # Layer for total civilian conflicts\n  tm_shape(finalized_map) +\n  tm_polygons(\"fatality_density\", \n              title = \"Myanmar State by Fatalies For Civilians Related Conflicts Density Per Km^2\",\n              palette = \"Blues\", \n              border.col = \"black\", \n              alpha = 0.8,  # Transparency for polygons\n              border.alpha = 0.5,  # Semi-transparent border\n              id = \"state\") +  # Set state as identifier for the polygons\n\n  # Layout settings matching your style\n  tm_layout(\n    main.title = \"Myanmar State by Fatalies For Civilians Related Conflicts Density Per Km^2\",  # Main map title\n    main.title.size = 1.0,  # Title font size\n    legend.outside = TRUE,  # Position legend outside the map\n    legend.outside.size = 0.5,  # Adjust size of outside legend\n    legend.position = c(\"left\", \"top\"),  # Position for the event type legend\n    legend.title.size = 1.0,  # Size of the legend title\n    legend.text.size = 0.8,  # Size of the legend text\n    legend.bg.color = \"white\",  # Background color for the legend\n    legend.bg.alpha = 0.5,  # Transparency for the legend background\n    inner.margins = c(0.05, 0.05, 0.05, 0.05)  # Set inner margins for better spacing\n  )\n\ntm_fatalities_conflict\n\n\n\n\n\n\n\n\n\n\n\ntm_fatalities_density &lt;-\n  # Layer for total civilian conflicts\n  tm_shape(finalized_map) +\n  tm_polygons(\"fatality_per_conflict\", \n              title = \"Myanmar State by Fatalies for Civilian Related Conflicts\",\n              palette = \"Blues\", \n              border.col = \"black\", \n              alpha = 0.8,  # Transparency for polygons\n              border.alpha = 0.5,  # Semi-transparent border\n              id = \"state\") +  # Set state as identifier for the polygons\n\n  # Layout settings matching your style\n  tm_layout(\n    main.title = \"Myanmar State by Fatalies for Civilian Related Conflicts\",  # Main map title\n    main.title.size = 1.0,  # Title font size\n    legend.outside = TRUE,  # Position legend outside the map\n    legend.outside.size = 0.5,  # Adjust size of outside legend\n    legend.position = c(\"left\", \"top\"),  # Position for the event type legend\n    legend.title.size = 1.0,  # Size of the legend title\n    legend.text.size = 0.8,  # Size of the legend text\n    legend.bg.color = \"white\",  # Background color for the legend\n    legend.bg.alpha = 0.5,  # Transparency for the legend background\n    inner.margins = c(0.05, 0.05, 0.05, 0.05)  # Set inner margins for better spacing\n  )\n\ntm_fatalities_density"
  },
  {
    "objectID": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#analysis-on-the-aggregated-data-to-find-top-3-state-to-analyse",
    "href": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#analysis-on-the-aggregated-data-to-find-top-3-state-to-analyse",
    "title": "Take_Home Exercise 1: Geospatial Analytics for Social Good: Application of Spatial and Spatio-temporal Point Patterns Analysis to discover the geographical distribution of Armed Conflict in Myanmar",
    "section": "4.3 Analysis on the aggregated data to find top 3 state to analyse",
    "text": "4.3 Analysis on the aggregated data to find top 3 state to analyse\n\n4.3.1 Choose which States to analyse?\nWith the maps above, everyone can choose what they would like to analyze, whether it’s total civilian conflicts or fatalities by state. However, I would like to focus on the central question:\nWhich state has the highest amount of conflict and fatality density?\nBy using density, I’ve aimed to assess fatalities in relation to conflicts and ensure a fair comparison by adjusting for density.\n\n\n\n\n\n\nNote\n\n\n\nKeep in mind, this is not the most precise analysis, as other factors—such as ethnicity, population demographics, and gender—could also be considered. However, for the purpose of this study, I have chosen to focus on solely on the state’s conflict and fatality density.\n\n\nConflict Density: This is the number of conflicts per square kilometer in a state.\n\nConflict Density=Total ConflictsArea of State (km²) = Conflict Density=Area of State (km²)Total Conflicts​\nThis tells you how many conflicts occur per unit of area (1 km²) in each state.\nFatality Density: This is the number of fatalities per square kilometer.\nFatality Density=Total FatalitiesArea of State (km²) = Fatality Density=Area of State (km²)Total Fatalities​\n\n\n\n4.3.2 Viewing the top 3 states across\nUsing the map below, you can interactively explore the Conflict and Fatality Density. We observe that the top three states are as follows, and here’s how they compare across the data set.\nYou can use the layer toggle to switch between fatalities and conflicts, or click on the map layers to view detailed, aggregated data for each state.\n\n# Step 1: Set tmap mode to view for interactive maps\n\n# Step 2: Define popup variables to show all relevant columns when clicking on a state\npopup_variables &lt;- c( \n                     \"Total Civilian Conflicts\" = \"total_conflicts\",\n                     \"Fatalities\" = \"total_fatalities\",\n                     \"Civilian Conflict Density\" = \"conflict_density\",\n                     \"Fatality Density\" = \"fatality_density\",\n                     \"Fatality Per Civilian Conflict\" = \"fatality_per_conflict\",\n                     \"Ranked For Total Conflict By State (Out of 15)\" = \"rank_total_conflicts\",\n                     \"Ranked For Total Fatalities By State (Out of 15)\" = \"rank_total_fatalities\",\n                     \"Ranked For Conflict Density By State (Out of 15)\" = \"rank_conflict_density\",\n                     \"Ranked For Fatalities Density By State (Out of 15)\" = \"rank_fatality_density\",\n                     \"Ranked For Fatalies/Conflict By State (Out of 15)\" = \"rank_fatality_per_conflict\"\n                     )\n\n# Step 3: Create the map with 6 layers for toggling\ntm &lt;- tm_basemap(server = \"OpenStreetMap\") +\n  tm_shape(finalized_map) +\n  tm_polygons(\"conflict_density\", \n              title = \"Civilian Conflict Density\",\n              palette = \"Oranges\", \n              border.col = \"black\",\n              popup.vars = popup_variables,\n              id = \"state\", \n              group = \"Civilian Conflict Density\") +\n  tm_shape(finalized_map) +\n  tm_polygons(\"fatality_density\", \n              title = \"Fatality Density\",\n              palette = \"Purples\", \n              border.col = \"black\",\n              popup.vars = popup_variables,\n              id = \"state\", \n              group = \"Fatality Density\") +\n  tm_layout(\n    legend.outside = TRUE,\n    legend.outside.size = 0.5,  # Adjust the size of the legend\n    legend.position = c(\"left\", \"top\")  # Position the legend\n  )\n# Step 5: Display the interactive map\ntm\n\nlegend.postion is used for plot mode. Use view.legend.position in tm_view to set the legend position in view mode.\n\n\n\n\n\n\nHere we build the bar chart to view rank the states base on the variables.\n\nfinalized_data_df &lt;- as.data.frame(st_drop_geometry(finalized_map))\n# Sort the data by conflict_density and fatality_density in descending order\nfinalized_data_df &lt;- finalized_data_df %&gt;%\n  arrange(desc(conflict_density), desc(fatality_density))\n\n# Format the densities to show \"per km²\"\nfinalized_data_df$conflict_density_label &lt;- paste0(round(finalized_data_df$conflict_density, 2), \" per km²\")\nfinalized_data_df$fatality_density_label &lt;- paste0(round(finalized_data_df$fatality_density, 2), \" per km²\")\n\n# Create bar chart for Conflict Density (sorted by conflict_density)\nconflict_density_plot &lt;- ggplot(finalized_data_df, aes(x = reorder(state, -conflict_density), y = conflict_density)) +\n  geom_bar(stat = \"identity\", fill = \"orange\") +\n  geom_text(aes(label = conflict_density_label), vjust = 1.8, size = 2.0, color = \"black\", position = position_stack(vjust = 0.5)) +  # Place text at bottom of bar\n  ggtitle(\"Top States by Conflict Density (per km²)\") +\n  xlab(\"State\") +\n  ylab(\"Conflict Density (per km²)\") +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))\n\n# Create bar chart for Fatality Density (sorted by fatality_density)\nfatality_density_plot &lt;- ggplot(finalized_data_df, aes(x = reorder(state, -fatality_density), y = fatality_density)) +\n  geom_bar(stat = \"identity\", fill = \"purple\") +\n  geom_text(aes(label = fatality_density_label), vjust = 1.8, size = 2.0, color = \"black\", position = position_stack(vjust = 0.5)) +  # Place text at bottom of bar\n  ggtitle(\"Top States by Fatality Density (per km²)\") +\n  xlab(\"State\") +\n  ylab(\"Fatality Density (per km²)\") +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))\n\n# Display both charts side by side\ngrid.arrange(conflict_density_plot, fatality_density_plot, ncol = 2)\n\n\n\n\n\n\n\n\n\n\n4.3.3 Top 3 Chosen state for further analysis\n\n4.3.3.1 Yangon\n\n\n\nYangon, Myanmar’s largest city and former capital, remains the country’s economic and cultural hub. Although it is no longer the political capital, Yangon holds the highest population density in the country, making it a vital urban center with significant influence.\nAccording to the data, Yangon ranks 5th for total conflicts, with 1,489 civilian conflicts reported, and 8th in fatalities, with 431 deaths. However, it stands out with the highest civilian conflict density (0.0531) and fatality density (0.01536) among Myanmar’s 15 states. This means that while the overall number of conflicts may not be the highest, they are more concentrated within Yangon’s urban area, resulting in the highest per-unit area conflict rate.\nYangon’s urbanization and strategic economic importance likely make it a hotspot for civilian unrest. Social tensions in a densely populated city lead to frequent conflicts, reflected in its rank of 1st for conflict density and fatality density. Despite fewer total conflicts compared to other states, Yangon’s density of unrest highlights its vulnerability to civil tensions.\n\n\n4.3.3.2 Mandalay\n\nMandalay, the second-largest city in Myanmar, is known for its cultural significance and central location in the country. It holds a key strategic position in the economy and transportation networks, making it vulnerable to unrest.\nThe data shows Mandalay ranks 2nd for total civilian conflicts with 2,021 conflicts and 950 fatalities. Its civilian conflict density is 0.0255, placing it 3rd in density, while its fatality density is 0.0120, ranked 2nd. Despite being second in conflict counts, the concentration of conflicts and fatalities suggests that civil unrest is deeply rooted in the region, but not as dense as in Yangon.\nMandalay’s high fatality-to-conflict ratio (0.4701 fatalities per conflict) highlights the deadly nature of conflicts, ranking 7th in fatalities per conflict. This reflects a region where conflicts, though frequent, lead to significant loss of life compared to other states.\n\n\n4.3.3.3 Sagaling.\n\nSagaing, located in northern Myanmar, is one of the country’s most conflict-ridden regions, often affected by armed insurgencies and ethnic clashes due to its proximity to volatile borders.\nThe data reveals that Sagaing ranks 1st in total civilian conflicts with 5,346 conflicts and 3,319 fatalities, giving it the highest fatality count as well. However, its civilian conflict density is 0.0241 (ranked 3rd) and its fatality density is 0.01497 (ranked 3rd), indicating a widespread yet slightly less concentrated conflict zone compared to Yangon and Mandalay.\nSagaing’s fatality per civilian conflict ratio of 0.6208 ranks 2nd, emphasizing the high lethality of conflicts in the region. With both the largest number of conflicts and a high fatality rate, Sagaing represents one of the most dangerous and unstable areas in Myanmar for civilians/"
  },
  {
    "objectID": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#final-round-of-cleansing-acled-data",
    "href": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#final-round-of-cleansing-acled-data",
    "title": "Take_Home Exercise 1: Geospatial Analytics for Social Good: Application of Spatial and Spatio-temporal Point Patterns Analysis to discover the geographical distribution of Armed Conflict in Myanmar",
    "section": "4.4 Final Round of Cleansing ACLED Data",
    "text": "4.4 Final Round of Cleansing ACLED Data\nIn this final stage of the data cleansing process, we focus on preparing the ACLED (Armed Conflict Location & Event Data) for the different states. The key steps include:\n\nFiltering: We first filter the dataset to focus on data specific to Yangon.\nConverting to Spatial Format: Using the st_as_sf() function, we transform the filtered data into a simple features (sf) object, a format commonly used for spatial data in R. This involves specifying longitude and latitude as the coordinates and setting the correct WGS84 (CRS 4326) coordinate system for global geographic data.\nCoordinate System Transformation: We apply the st_transform() function to project the spatial data from WGS84 (CRS 4326) to UTM Zone 47N (CRS 32647), which is more appropriate for spatial analysis in Myanmar. This step ensures accurate distance and area calculations.\nValidity Check: Using st_is_valid(), we validate the geometries in the spatial data to ensure there are no invalid shapes, such as self-intersecting polygons, which could cause errors during analysis.\nConversion to Spatial Data Frame: Finally, we convert the sf object into a Spatial Data Frame (as_Spatial()) for compatibility with specific spatial analysis functions that require this format.\n\nThis process ensures that the States data is accurately represented in a geospatial format, with proper coordinate transformation and validity checks applied. It prepares the data for further geospatial operations, such as mapping and spatial pattern analysis, with the confidence that the dataset is clean and valid for use.\n\nYangonMandalaySagaing\n\n\n\n# Filter data for Yangon state from the entire ACLED dataset\nYangon_ACLED_Data &lt;- filtered_data %&gt;% \n  filter(state %in% c(\"Yangon\"))\n\n# Check the class of the data to confirm it's a dataframe\nclass(Yangon_ACLED_Data)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n# Convert the filtered data into a spatial format (simple features object)\n# Use longitude and latitude columns as coordinates, with WGS84 (CRS 4326) as the coordinate system\nYangon_ACLED_Data_Sf &lt;- st_as_sf(Yangon_ACLED_Data, coords = c(\"longitude\", \"latitude\"), crs = 4326, remove = FALSE)\n\n# Transform the coordinate system to UTM Zone 47N (CRS 32647) for better spatial precision in Myanmar\nYangon_ACLED_Data_Sf &lt;- st_transform(Yangon_ACLED_Data_Sf, crs = 32647)\n\n# Check the class of the spatial object to confirm conversion\nclass(Yangon_ACLED_Data_Sf)\n\n[1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n# Validate the spatial object to ensure all geometries are valid (no broken or self-intersecting geometries)\nYangon_ACLED_Validity &lt;- st_is_valid(Yangon_ACLED_Data_Sf)\n\n# Identify any invalid geometries and print them if they exist\nYangon_invalid &lt;- which(!Yangon_ACLED_Validity)\nif (length(Yangon_invalid) &gt; 0) {\n  print(\"Yangon is Invalid!\")\n  print(Yangon_ACLED_Data_Sf[Yangon_invalid, ])\n} else {\n  print(\"Yangon_ACLED_Data_Sf is valid!\")\n}\n\n[1] \"Yangon_ACLED_Data_Sf is valid!\"\n\n# Convert the sf object into a Spatial Data Frame (for compatibility with certain spatial analysis functions)\nYangon_ACLED_SFDF &lt;- as_Spatial(Yangon_ACLED_Data_Sf)\n\n# Final output - Yangon ACLED data in spatial data frame format, ready for analysis\nYangon_ACLED_SFDF\n\nclass       : SpatialPointsDataFrame \nfeatures    : 1489 \nextent      : 148595, 259745.5, 1819680, 1944325  (xmin, xmax, ymin, ymax)\ncrs         : +proj=utm +zone=47 +datum=WGS84 +units=m +no_defs \nvariables   : 20\nnames       : event_id_cnty, event_date, year,          disorder_type,                 event_type,                       actor1, inter1,                actor2, inter2, interaction,      location, latitude, longitude, fatalities, quarter_year, ... \nmin values  :      MMR10949,      18633, 2021,     Political violence, Explosions/Remote violence,           5 Brothers Younger,      1, Civilians (Australia),      0,          17,     Ah Hpyauk,  16.4389,   95.6934,          0,      Q1-2021, ... \nmax values  :      MMR64089,      19895, 2024, Strategic developments, Violence against civilians, YUG: Yangon Urban Guerrillas,      7,                    NA,      7,          70, Zee Hpyu Kone,  17.5612,   96.7448,         13,      Q4-2023, ... \n\n\n\n\n\n# Filter data for Mandalay state from the entire ACLED dataset\nMandalay_ACLED_Data &lt;- filtered_data %&gt;% \n  filter(state %in% c(\"Mandalay\"))\n# Check the class of the filtered data to confirm it's still a dataframe\nclass(Mandalay_ACLED_Data)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n# Convert the filtered data into a spatial format (simple features object)\n# Longitude and latitude are used as coordinates, and WGS84 (CRS 4326) is set as the coordinate system\nMandalay_ACLED_Data_Sf &lt;- st_as_sf(Mandalay_ACLED_Data, coords = c(\"longitude\", \"latitude\"), crs = 4326, remove = FALSE)\n\n# Transform the coordinate system to UTM Zone 47N (CRS 32647) for better accuracy in the Myanmar region\nMandalay_ACLED_Data_Sf &lt;- st_transform(Mandalay_ACLED_Data_Sf, crs = 32647)\n\n# Verify that the data has been successfully converted into a spatial object\nclass(Mandalay_ACLED_Data_Sf)\n\n[1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n# Validate the spatial data to check for any invalid geometries (e.g., self-intersections, broken polygons)\nMandalay_ACLED_Validity &lt;- st_is_valid(Mandalay_ACLED_Data_Sf)\n\n# Identify any invalid geometries and print them for inspection, if found\nMandalay_invalid &lt;- which(!Mandalay_ACLED_Validity)\nif (length(Mandalay_invalid) &gt; 0) {\n  print(\"Mandalay is Invalid!\")\n  print(Mandalay_ACLED_Data_Sf[Mandalay_invalid, ])\n} else {\n  # If all geometries are valid, print confirmation\n  print(\"Mandalay_ACLED_Data_Sf is valid!\")\n}\n\n[1] \"Mandalay_ACLED_Data_Sf is valid!\"\n\n# Convert the simple features object to a Spatial Data Frame for compatibility with spatial functions\nMandalay_ACLED_SFDF &lt;- as_Spatial(Mandalay_ACLED_Data_Sf)\n\n# Final output - Mandalay ACLED data in spatial data frame format, ready for analysis\nMandalay_ACLED_SFDF\n\nclass       : SpatialPointsDataFrame \nfeatures    : 2021 \nextent      : 68129.21, 255317.2, 2261881, 2620357  (xmin, xmax, ymin, ymax)\ncrs         : +proj=utm +zone=47 +datum=WGS84 +units=m +no_defs \nvariables   : 20\nnames       : event_id_cnty, event_date, year,          disorder_type,                 event_type,                                   actor1, inter1,              actor2, inter2, interaction,         location, latitude, longitude, fatalities, quarter_year, ... \nmin values  :      MMR10960,      18640, 2021,     Political violence, Explosions/Remote violence, 21KPG: 21 Guerrilla Force - Kyaukpadaung,      1, Civilians (Myanmar),      0,          17, 4 Maing Kan Thar,  20.4319,    94.849,          0,      Q1-2021, ... \nmax values  :      MMR64318,      19904, 2024, Strategic developments, Violence against civilians,          Zero Guerrilla Force - Myingyan,      7,                  NA,      7,          70,       Zin Chaung,   23.667,   96.6148,         10,      Q4-2023, ... \n\n\n\n\n\nSagaing_ACLED_Data &lt;- filtered_data %&gt;% \n  filter(state %in% c(\"Sagaing\"))\n\n# Check the class of the filtered data to confirm it's still a dataframe\nclass(Sagaing_ACLED_Data)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n# Convert the filtered data into a spatial format (simple features object)\n# Longitude and latitude are used as coordinates, and WGS84 (CRS 4326) is set as the coordinate system\nSagaing_ACLED_Data_Sf &lt;- st_as_sf(Sagaing_ACLED_Data, coords = c(\"longitude\", \"latitude\"), crs = 4326, remove = FALSE)\n\n# Transform the coordinate system to UTM Zone 47N (CRS 32647) for better accuracy in the Myanmar region\nSagaing_ACLED_Data_Sf &lt;- st_transform(Sagaing_ACLED_Data_Sf, crs = 32647)\n\n# Verify that the data has been successfully converted into a spatial object\nclass(Sagaing_ACLED_Data_Sf)\n\n[1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n# Validate the spatial data to check for any invalid geometries (e.g., self-intersections, broken polygons)\nSagaing_ACLED_Validity &lt;- st_is_valid(Sagaing_ACLED_Data_Sf)\n\n# Identify any invalid geometries and print them for inspection, if found\nSagaing_invalid &lt;- which(!Sagaing_ACLED_Validity)\nif (length(Sagaing_invalid) &gt; 0) {\n  print(\"Sagaing is Invalid!\")\n  print(Sagaing_ACLED_Data_Sf[Sagaing_invalid, ])\n} else {\n  # If all geometries are valid, print confirmation\n  print(\"Sagaing_ACLED_Data_Sf is valid!\")\n}\n\n[1] \"Sagaing_ACLED_Data_Sf is valid!\"\n\n# Convert the simple features object to a Spatial Data Frame for compatibility with spatial functions\nSagaing_ACLED_SFDF &lt;- as_Spatial(Sagaing_ACLED_Data_Sf)\n\n# Final output - Sagaing ACLED data in spatial data frame format, ready for analysis\nSagaing_ACLED_SFDF\n\nclass       : SpatialPointsDataFrame \nfeatures    : 5346 \nextent      : -16397.05, 256586.9, 2393568, 2914063  (xmin, xmax, ymin, ymax)\ncrs         : +proj=utm +zone=47 +datum=WGS84 +units=m +no_defs \nvariables   : 20\nnames       : event_id_cnty, event_date, year,          disorder_type,                 event_type,                                      actor1, inter1,            actor2, inter2, interaction,               location, latitude, longitude, fatalities, quarter_year, ... \nmin values  :      MMR10952,      18640, 2021,     Political violence, Explosions/Remote violence, ABSDF: All Burma Students' Democratic Front,      1, Civilians (China),      0,          17,               55 Maing,   21.605,   93.9575,          0,      Q1-2021, ... \nmax values  :      MMR65891,      19898, 2024, Strategic developments, Violence against civilians,             Zero Guerrilla Force - Myingyan,      7,                NA,      7,          70, Zin Ka Le (Zin Ka Lin),  26.3006,   96.6034,        175,      Q4-2023, ..."
  },
  {
    "objectID": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#setting-up-the-owin-window-for-states.",
    "href": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#setting-up-the-owin-window-for-states.",
    "title": "Take_Home Exercise 1: Geospatial Analytics for Social Good: Application of Spatial and Spatio-temporal Point Patterns Analysis to discover the geographical distribution of Armed Conflict in Myanmar",
    "section": "5.1 Setting up the Owin Window for States.",
    "text": "5.1 Setting up the Owin Window for States.\nIn this step, we are setting up an owin object for each state using the spatstat package. An owin object defines the spatial window—or the boundary—within which our point pattern analysis will take place. Essentially, this window will encapsulate the polygonal boundary of each state, allowing us to focus on conflict data within those precise boundaries.\nTo create the owin object, we will:\n\nExtract the polygon boundaries for each state from the spatial data.\nConvert these boundaries into an owin object using the as.owin() function.\nThese spatial windows will ensure that all spatial operations, such as density estimation and pattern analysis, occur strictly within the boundaries of the specified state (e.g., Yangon, Mandalay, Sagaing).\n\nThis setup is crucial for ensuring that our spatial analysis focuses only on relevant geographic areas and doesn’t incorporate any points outside the boundaries.\n\nYangonMandalaySagaing\n\n\n\nYangon_Sf &lt;- M_State_Sf %&gt;% \n  filter(state %in% c(\"Yangon\"))\n# Step 1: Extract the individual polygons from the multipolygon\nyangon_polygons &lt;- st_cast(Yangon_Sf$geometry, \"POLYGON\")\nyangon_polygons_filtered &lt;- yangon_polygons[-c(1, 2)]\nyangon_multipolygon_filtered &lt;- st_combine(yangon_polygons_filtered)\n# Add the filtered multipolygon back to the Yangon_Sf object\nYangon_Sf$geometry &lt;- yangon_multipolygon_filtered\nYangon &lt;- as_Spatial(Yangon_Sf)\nYangon_Owin &lt;- as.owin(Yangon_Sf)\nplot(Yangon_Owin)\n\n\n\n\n\n\n\nsummary(Yangon_Owin)\n\nWindow: polygonal boundary\n6 separate polygons (1 hole)\n                 vertices         area relative.area\npolygon 1            3832  9.84832e+09      1.00e+00\npolygon 2 (hole)        3 -1.78834e+02     -1.82e-08\npolygon 3              14  2.11571e+05      2.15e-05\npolygon 4              11  1.59536e+05      1.62e-05\npolygon 5              20  1.79201e+06      1.82e-04\npolygon 6              37  2.56010e+06      2.60e-04\nenclosing rectangle: [140506.53, 268404.01] x [1805599.6, 1970174] units\n                     (127900 x 164600 units)\nWindow area = 9853040000 square units\nFraction of frame area: 0.468\n\n\n\n\n\n# Filter the dataset to only include data for Mandalay state\nMandalay_Sf &lt;- M_State_Sf %&gt;% \n  filter(state %in% c(\"Mandalay\"))\n# Convert the Mandalay spatial dataframe into a Spatial Data Frame for further spatial operations\nMandalay &lt;- as_Spatial(Mandalay_Sf)\n\n# Convert the Mandalay spatial dataframe into an owin object for spatial point pattern analysis\nMandalay_Owin &lt;- as.owin(Mandalay_Sf)\n\n# Plot the owin object to visualize the boundaries of Mandalay\nplot(Mandalay_Owin)\n\n\n\n\n\n\n\n# Provide a summary of the owin object, showing its properties like dimensions and bounding box\nsummary(Mandalay_Owin)\n\nWindow: polygonal boundary\nsingle connected closed polygon with 5914 vertices\nenclosing rectangle: [66291.97, 282396.46] x [2234807.4, 2622191.5] units\n                     (216100 x 387400 units)\nWindow area = 30998600000 square units\nFraction of frame area: 0.37\n\n\n\n\n\n# Filter the dataset to only include data for Sagaing state\nSagaing_Sf &lt;- M_State_Sf %&gt;% \n  filter(state %in% c(\"Sagaing\"))\n\n# Convert the Sagaing spatial dataframe into a Spatial Data Frame for further spatial operations\nSagaing &lt;- as_Spatial(Sagaing_Sf)\n\n# Convert the Sagaing spatial dataframe into an owin object for spatial point pattern analysis\nSagaing_Owin &lt;- as.owin(Sagaing_Sf)\n# Plot the owin object to visualize the boundaries of Sagaing\nplot(Sagaing_Owin)\n\n\n\n\n\n\n\n# Provide a summary of the owin object, showing its properties like dimensions and bounding box\nsummary(Sagaing_Owin)\n\nWindow: polygonal boundary\nsingle connected closed polygon with 5882 vertices\nenclosing rectangle: [-17699.96, 308341.37] x [2390344.6, 3029739.1] units\n                     (326000 x 639400 units)\nWindow area = 9.3875e+10 square units\nFraction of frame area: 0.45"
  },
  {
    "objectID": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#setting-up-the-acled-spatial-class",
    "href": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#setting-up-the-acled-spatial-class",
    "title": "Take_Home Exercise 1: Geospatial Analytics for Social Good: Application of Spatial and Spatio-temporal Point Patterns Analysis to discover the geographical distribution of Armed Conflict in Myanmar",
    "section": "5.2 Setting up the ACLED Spatial Class",
    "text": "5.2 Setting up the ACLED Spatial Class\nAfter defining the owin window for each state, we need to convert the conflict data into a suitable spatial point pattern object (typically using spatstat’s ppp class). This class is essential for performing spatial point pattern analysis, as it links the geographic coordinates of conflict events to the state boundary.\nHere’s what we’ll do:\n\nWe will first ensure that the conflict data is transformed into the appropriate spatial projection (UTM or other applicable projections).\nThe conflict data points will be linked to the owin window to define where these events occur within the state’s boundary.\nThe result will be a ppp (point pattern) object, which is necessary for conducting spatial operations like density estimation, K-function analysis, or G-function analysis.\n\nThis step transforms our dataset into a fully spatially aware format, ready for statistical analysis.\n\nYangonMandalaySagaing\n\n\n\n# Extract the coordinates (longitude, latitude) from the Yangon spatial object\nYangon_ACLED_coords &lt;- st_coordinates(Yangon_ACLED_Data_Sf)\n\n# Define the bounding box (xmin, xmax, ymin, ymax) for Yangon, which sets the spatial extent of the window\nYangon_ACLED_bbox &lt;- st_bbox(Yangon_ACLED_Data_Sf)\n\n# Create the spatial window (owin object) for Yangon using the bounding box ranges\nYangon_ACLED_window &lt;- owin(xrange = Yangon_ACLED_bbox[c(\"xmin\", \"xmax\")], yrange = Yangon_ACLED_bbox[c(\"ymin\", \"ymax\")])\n\n# Create a ppp (point pattern) object for Yangon using the extracted coordinates and the defined window\nYangon_ACLED_ppp &lt;- ppp(x = Yangon_ACLED_coords[, 1], y = Yangon_ACLED_coords[, 2], window = Yangon_ACLED_window)\n# Check the summary of the ppp object to verify the number of points, window dimensions, and other properties\nsummary(Yangon_ACLED_ppp)\n\nPlanar point pattern:  1489 points\nAverage intensity 1.074751e-07 points per square unit\n\n*Pattern contains duplicated points*\n\nCoordinates are given to 10 decimal places\n\nWindow: rectangle = [148595.03, 259745.55] x [1819680.1, 1944325.3] units\n                    (111200 x 124600 units)\nWindow area = 13854400000 square units\n\n# Plot the ppp object to visually inspect the spatial distribution of conflict points in Yangon\nplot(Yangon_ACLED_ppp)\n\n\n\n\n\n\n\n\n\n\n\n# Extract the coordinates (longitude, latitude) from the Mandalay spatial object\nMandalay_ACLED_coords &lt;- st_coordinates(Mandalay_ACLED_Data_Sf)\n\n# Define the bounding box (xmin, xmax, ymin, ymax) for Mandalay, which sets the spatial extent of the window\nMandalay_ACLED_bbox &lt;- st_bbox(Mandalay_ACLED_Data_Sf)\n\n# Create the spatial window (owin object) for Mandalay using the bounding box ranges\nMandalay_ACLED_window &lt;- owin(xrange = Mandalay_ACLED_bbox[c(\"xmin\", \"xmax\")], yrange = Mandalay_ACLED_bbox[c(\"ymin\", \"ymax\")])\n\n# Create a ppp (point pattern) object for Mandalay using the extracted coordinates and the defined window\nMandalay_ACLED_ppp &lt;- ppp(x = Mandalay_ACLED_coords[, 1], y = Mandalay_ACLED_coords[, 2], window = Mandalay_ACLED_window)\n\n# Check the summary of the ppp object to verify the number of points, window dimensions, and other properties\nsummary(Mandalay_ACLED_ppp)\n\nPlanar point pattern:  2021 points\nAverage intensity 3.011815e-08 points per square unit\n\n*Pattern contains duplicated points*\n\nCoordinates are given to 11 decimal places\n\nWindow: rectangle = [68129.21, 255317.22] x [2261880.7, 2620356.6] units\n                    (187200 x 358500 units)\nWindow area = 67102400000 square units\n\n# Plot the ppp object to visually inspect the spatial distribution of conflict points in Mandalay\nplot(Mandalay_ACLED_ppp)\n\n\n\n\n\n\n\n\n\n\n\n# Extract the coordinates (longitude, latitude) from the Sagaing spatial object\nSagaing_ACLED_coords &lt;- st_coordinates(Sagaing_ACLED_Data_Sf)\n\n# Define the bounding box (xmin, xmax, ymin, ymax) for Sagaing, which sets the spatial extent of the window\nSagaing_ACLED_bbox &lt;- st_bbox(Sagaing_ACLED_Data_Sf)\n\n# Create the spatial window (owin object) for Sagaing using the bounding box ranges\nSagaing_ACLED_window &lt;- owin(xrange = Sagaing_ACLED_bbox[c(\"xmin\", \"xmax\")], yrange = Sagaing_ACLED_bbox[c(\"ymin\", \"ymax\")])\n\n# Create a ppp (point pattern) object for Sagaing using the extracted coordinates and the defined window\nSagaing_ACLED_ppp &lt;- ppp(x = Sagaing_ACLED_coords[, 1], y = Sagaing_ACLED_coords[, 2], window = Sagaing_ACLED_window)\n# Check the summary of the ppp object to verify the number of points, window dimensions, and other properties\nsummary(Sagaing_ACLED_ppp)\n\nPlanar point pattern:  5346 points\nAverage intensity 3.762491e-08 points per square unit\n\n*Pattern contains duplicated points*\n\nCoordinates are given to 13 decimal places\n\nWindow: rectangle = [-16397.05, 256586.9] x [2393568.1, 2914062.9] units\n                    (273000 x 520500 units)\nWindow area = 1.42087e+11 square units\n\n# Plot the ppp object to visually inspect the spatial distribution of conflict points in Sagaing\nplot(Sagaing_ACLED_ppp)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nWhy dont you jitter, delete or mark any conflicts here?\nThe reason I did not apply jittering, deletion, or marking of the conflicts at this stage is that all the conflicts are unique and occurred across different time zones. Since there is no overlap in terms of exact location or time, it makes no sense to modify the data at this point. We will consider jittering later if we find that events are clustered too closely together in space, but for now, each conflict is distinct, and no adjustments are necessary."
  },
  {
    "objectID": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#combining-them-both",
    "href": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#combining-them-both",
    "title": "Take_Home Exercise 1: Geospatial Analytics for Social Good: Application of Spatial and Spatio-temporal Point Patterns Analysis to discover the geographical distribution of Armed Conflict in Myanmar",
    "section": "5.3 Combining them both",
    "text": "5.3 Combining them both\nFinally, we will merge the owin object (state boundary) and the spatial point pattern data (conflict events) into a single object. This combination ensures that:\n\nThe spatial window constrains the analysis, focusing on the area within each state’s boundary.\nAll conflict events are accurately represented within the confines of the defined boundary.\n\nThis step allows for robust spatial point pattern analysis, ensuring that both the boundaries and events are properly accounted for. With this merged object, we can perform advanced geospatial techniques, such as analyzing the distribution of conflict events, identifying hotspots, and calculating density functions within the state.\n\nYangonMandalaySagaing\n\n\n\nYangon_ACLED_ppp = Yangon_ACLED_ppp[Yangon_Owin]\nplot(Yangon_ACLED_ppp)\n\n\n\n\n\n\n\n\n\n\n\nMandalay_ACLED_ppp = Mandalay_ACLED_ppp[Mandalay_Owin]\nplot(Mandalay_ACLED_ppp)\n\n\n\n\n\n\n\n\n\n\n\nSagaing_ACLED_ppp = Sagaing_ACLED_ppp[Sagaing_Owin]\nplot(Sagaing_ACLED_ppp)"
  },
  {
    "objectID": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#setting-up-a-function-to-create-quarterly-for-each-state",
    "href": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#setting-up-a-function-to-create-quarterly-for-each-state",
    "title": "Take_Home Exercise 1: Geospatial Analytics for Social Good: Application of Spatial and Spatio-temporal Point Patterns Analysis to discover the geographical distribution of Armed Conflict in Myanmar",
    "section": "7.1 Setting up a function to create quarterly for each state",
    "text": "7.1 Setting up a function to create quarterly for each state\nWe will create a function that takes the conflict data for each state and computes the quarterly KDE. This function will:\n\nFilter the conflict events by quarter.\nApply the KDE to estimate the spatial density of events for that quarter.\nReturn a KDE layer that can be used for visualization and analysis.\n\n\n\nFull Code\n\n\nprocess_quarter_conflicts &lt;- function(region_sf, region_window, region_name, data_sf, sigma_type, kernel_method) {\n  # Extract unique quarters (reversed for correct order)\n  quarters &lt;- rev(unique(data_sf$quarter_year))\n  \n  # Initialize empty lists to store ppp and KDE objects\n  region_quarters_conflict &lt;- list()\n  kde_plot_list &lt;- list()\n  \n  # Step 2: Loop over each quarter and process conflict data\n  for (quarter in quarters) {\n    # Filter the data for the current quarter\n    quarter_data &lt;- data_sf %&gt;%\n      filter(quarter_year == quarter)\n    \n    # Extract coordinates for this quarter\n    quarter_coords &lt;- st_coordinates(quarter_data)\n    \n    # Create a ppp object for this quarter\n    quarter_ppp &lt;- ppp(\n      x = quarter_coords[, 1],\n      y = quarter_coords[, 2],\n      window = region_window\n    )\n    \n    # Step 3: Remove rejected points that fall outside the window\n    valid_points &lt;- inside.owin(quarter_ppp$x, quarter_ppp$y, region_window)\n    quarter_ppp &lt;- quarter_ppp[valid_points]\n    \n    # Step 4: Jitter duplicates to avoid overplotting\n    is_duplicate &lt;- duplicated(quarter_ppp)\n    jittered_x &lt;- quarter_ppp$x + ifelse(is_duplicate, runif(npoints(quarter_ppp), -0.1, 0.1), 0)\n    jittered_y &lt;- quarter_ppp$y + ifelse(is_duplicate, runif(npoints(quarter_ppp), -0.1, 0.1), 0)\n    \n    # Create a jittered ppp object with the new coordinates\n    jittered_ppp &lt;- ppp(\n      x = jittered_x,\n      y = jittered_y,\n      window = region_window\n    )\n    \n    # Step 5: Store the jittered ppp object for later use\n    region_quarters_conflict[[quarter]] &lt;- jittered_ppp\n    \n    # Step 6: Rescale to kilometers and calculate KDE with specified sigma type and kernel method\n    jittered_ppp_km &lt;- rescale(jittered_ppp, 1000, \"km\")\n    \n    # Use selected sigma type\n    if (sigma_type == \"scott\") {\n      sigma_value &lt;- bw.scott(jittered_ppp_km)\n      kde_quarter &lt;- density(jittered_ppp_km, sigma = bw.scott(jittered_ppp_km), edge = TRUE, kernel = kernel_method)\n    } else if (sigma_type == \"diggle\") {\n      sigma_value &lt;- bw.scott(jittered_ppp_km)\n      kde_quarter &lt;- density(jittered_ppp_km, sigma = bw.diggle(jittered_ppp_km), edge = TRUE, kernel = kernel_method)\n    } else if (sigma_type == \"ppl\") {\n      sigma_value &lt;- bw.scott(jittered_ppp_km)\n      kde_quarter &lt;- density(jittered_ppp_km, sigma = bw.ppl(jittered_ppp_km), edge = TRUE, kernel = kernel_method)\n    } else if (sigma_type == \"cvl\") {\n      sigma_value &lt;- bw.scott(jittered_ppp_km)\n      kde_quarter &lt;- density(jittered_ppp_km, sigma = bw.CvL(jittered_ppp_km), edge = TRUE, kernel = kernel_method)\n    } else {\n      stop(\"Invalid sigma_type specified.\")\n    }\n    \n    # Step 7: Store the KDE object for later use\n    kde_plot_list[[quarter]] &lt;- kde_quarter\n    \n    # Print a message after processing each quarter\n    print(paste(\"KDE - Quarter:\", quarter, \"| Kernel:\", kernel_method, \"| Sigma:\", sigma_type, \" | Sigma Value: \", sigma_value))\n  }\n  \n  # Return the processed ppp and KDE objects\n  return(list(\n    \"ppp_list\" = region_quarters_conflict,\n    \"kde_list\" = kde_plot_list\n  ))\n}"
  },
  {
    "objectID": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#setting-up-a-function-to-display-the-visual-across-quarters",
    "href": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#setting-up-a-function-to-display-the-visual-across-quarters",
    "title": "Take_Home Exercise 1: Geospatial Analytics for Social Good: Application of Spatial and Spatio-temporal Point Patterns Analysis to discover the geographical distribution of Armed Conflict in Myanmar",
    "section": "7.2 Setting up a function to display the visual across quarters",
    "text": "7.2 Setting up a function to display the visual across quarters\nNext, we will create a function to visualize the KDE layers for each quarter, enabling us to compare the intensity of conflict events over time. The function will:\n\nTake the KDE layers from each quarter.\nDisplay them side by side or as an animation to show how conflict density changes across quarters.\nThis visualization will help us observe trends, including whether conflicts are becoming more localized or dispersed over time.\n\n\n# Visualization Function for Conflict Points and KDE\nvisualize_conflict_results &lt;- function(results, region_name, sigma_type, kernel_method) {\n  ppp_list &lt;- results$ppp_list\n  kde_list &lt;- results$kde_list\n  \n  # Plotting Kernel Density Estimates (KDE) for each quarter\n  kde_plots &lt;- lapply(names(kde_list), function(quarter) {\n    kde_data &lt;- as.data.frame(as.im(kde_list[[quarter]]))\n    \n    ggplot() +\n      geom_raster(data = kde_data, aes(x = x, y = y, fill = value), alpha = 0.8) +\n      scale_fill_viridis_c(option = \"inferno\", name = \"Density\") +\n      labs(title = paste(\"KDE for Civilian Conflict\", region_name, \"-\", quarter)) +\n      theme_void() +  # Removes axis, background, and grid\n      theme(\n        plot.title = element_text(hjust = 0.5, face = \"bold\", size = 10, margin = margin(t = 10, b = 10)),  # Centers and adds margin to the title\n        plot.margin = margin(t = 5, r = 5, b = 5, l = 5)  # Adjusts the margin around the plot\n      )\n  })\n  \n  # Combine all plots into a grid layout with a main title\n  kde_grid &lt;- grid.arrange(grobs = kde_plots, ncol = 4, top = textGrob(\n    paste(region_name, \" Civilian Conflicts KDE By\", sigma_type, \"Using\", kernel_method, \"Kernel\"),\n    gp = gpar(fontface = \"bold\", fontsize = 16)\n  ))\n  \n  return(kde_grid)\n}"
  },
  {
    "objectID": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#states-quarterly-kernel-density-estimation.",
    "href": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#states-quarterly-kernel-density-estimation.",
    "title": "Take_Home Exercise 1: Geospatial Analytics for Social Good: Application of Spatial and Spatio-temporal Point Patterns Analysis to discover the geographical distribution of Armed Conflict in Myanmar",
    "section": "7.3 State’s Quarterly Kernel Density estimation.",
    "text": "7.3 State’s Quarterly Kernel Density estimation.\nFor each state, we will calculate and visualize the Kernel Density Estimation (KDE) using two different kernels. We focus on (You can use any we are flexible in the function above!)\n\nKernel 1: Gaussian Kernel\nKernel 2: Epanechnikov Kernel\n\nThe Gaussian Kernel is smooth and gives a global view of the density, whereas the Epanechnikov Kernel is more efficient and provides sharper boundaries, making it easier to identify clusters or hotspots.\nWe will also compute the KDE with different bandwidths, which controls the smoothness of the density estimates. A larger bandwidth results in smoother KDE, while a smaller bandwidth captures more local variations.\n\n7.3.1 Yangon\n\n7.3.1.1 Kernel 1: Gaussian Kernel\n\nDiggleScottCvLPPL\n\n\n\nYangon_Results_Diggle_Gaussian &lt;- process_quarter_conflicts(\n  region_sf = Yangon_Sf,\n  region_window = Yangon_Owin,\n  region_name = \"Yangon\",\n  data_sf = Yangon_ACLED_Data_Sf,\n  sigma_type = \"diggle\",  # Can change to \"scott\", \"diggle\", or \"ppl\"\n  kernel_method = \"gaussian\"  # Can change to \"epanechnikov\", \"quartic\", or others\n)\n\n\n# Step 4: Visualize the results with a main title\nvisualizations &lt;- visualize_conflict_results(Yangon_Results_Diggle_Gaussian, \"Yangon\", \"Diggle\", \"Gaussian\")\n\n\n\n\n\n\n\n\n\n\n\nYangon_Results_Scott_Gaussian &lt;- process_quarter_conflicts(\n  region_sf = Yangon_Sf,\n  region_window = Yangon_Owin,\n  region_name = \"Yangon\",\n  data_sf = Yangon_ACLED_Data_Sf,\n  sigma_type = \"scott\",  # Can change to \"scott\", \"diggle\", or \"ppl\"\n  kernel_method = \"gaussian\"  # Can change to \"epanechnikov\", \"quartic\", or others\n)\n\n\n# Step 4: Visualize the results with a main title\nYangon_Results_Scott_Gaussian_Visualisation &lt;- visualize_conflict_results(Yangon_Results_Scott_Gaussian, \"Yangon\", \"Scott\", \"Gaussian\")\n\n\n\n\n\n\n\n\n\n\n\nYangon_Results_CvL_Gaussian &lt;- process_quarter_conflicts(\n  region_sf = Yangon_Sf,\n  region_window = Yangon_Owin,\n  region_name = \"Yangon\",\n  data_sf = Yangon_ACLED_Data_Sf,\n  sigma_type = \"cvl\",  # Can change to \"scott\", \"diggle\", or \"ppl\"\n  kernel_method = \"gaussian\"  # Can change to \"epanechnikov\", \"quartic\", or others\n)\n\n\nYangon_Results_CvL_Gaussian_visualizations &lt;- visualize_conflict_results(Yangon_Results_CvL_Gaussian, \"Yangon\", \"CvL\", \"Gaussian\")\n\n\n\n\n\n\n\n\n\n\n\nYangon_Results_PPL_Gaussian &lt;- process_quarter_conflicts(\n  region_sf = Yangon_Sf,\n  region_window = Yangon_Owin,\n  region_name = \"Yangon\",\n  data_sf = Yangon_ACLED_Data_Sf,\n  sigma_type = \"ppl\",  # Can change to \"scott\", \"diggle\", or \"ppl\"\n  kernel_method = \"gaussian\"  # Can change to \"epanechnikov\", \"quartic\", or others\n)\n\n\n# Step 4: Visualize the results with a main title\nYangon_Results_PPL_Gaussian_visualizations &lt;- visualize_conflict_results(Yangon_Results_PPL_Gaussian, \"Yangon\", \"PPL\", \"Gaussian\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n7.3.1.2 Kernel 2: Epanechnikov Kernel\n\nDiggleScottCvLPPL\n\n\n\nYangon_Results_Diggle_Epanechnikov &lt;- process_quarter_conflicts(\n  region_sf = Yangon_Sf,\n  region_window = Yangon_Owin,\n  region_name = \"Yangon\",\n  data_sf = Yangon_ACLED_Data_Sf,\n  sigma_type = \"diggle\",  # Can change to \"scott\", \"diggle\", or \"ppl\"\n  kernel_method = \"epanechnikov\"  # Can change to \"epanechnikov\", \"quartic\", or others\n)\n\n\nYangon_Results_Diggle_Epanechnikov_visualizations &lt;- visualize_conflict_results(Yangon_Results_Diggle_Epanechnikov, \"Yangon\", \"Diggle\", \"Epanechnikov\")\n\n\n\n\n\n\n\n\n\n\n\nYangon_Results_Scott_Epanechnikov &lt;- process_quarter_conflicts(\n  region_sf = Yangon_Sf,\n  region_window = Yangon_Owin,\n  region_name = \"Yangon\",\n  data_sf = Yangon_ACLED_Data_Sf,\n  sigma_type = \"scott\",  # Can change to \"scott\", \"diggle\", or \"ppl\"\n  kernel_method = \"epanechnikov\"  # Can change to \"epanechnikov\", \"quartic\", or others\n)\n\n\nYangon_Results_Scot_Epanechnikov_visualizations &lt;- visualize_conflict_results(Yangon_Results_Scott_Epanechnikov, \"Yangon\", \"Scott\", \"Epanechnikov\")\n\n\n\n\n\n\n\n\n\n\n\nYangon_Results_CvL_Epanechnikov &lt;- process_quarter_conflicts(\n  region_sf = Yangon_Sf,\n  region_window = Yangon_Owin,\n  region_name = \"Yangon\",\n  data_sf = Yangon_ACLED_Data_Sf,\n  sigma_type = \"cvl\",  # Can change to \"scott\", \"diggle\", or \"ppl\"\n  kernel_method = \"epanechnikov\"  # Can change to \"epanechnikov\", \"quartic\", or others\n)\n\n\nYangon_Results_CvL_Epanechnikov_visualizations &lt;- visualize_conflict_results(Yangon_Results_CvL_Epanechnikov, \"Yangon\", \"CvL\", \"Epanechnikov\")\n\n\n\n\n\n\n\n\n\n\n\nYangon_Results_PPL_Epanechnikov &lt;- process_quarter_conflicts(\n  region_sf = Yangon_Sf,\n  region_window = Yangon_Owin,\n  region_name = \"Yangon\",\n  data_sf = Yangon_ACLED_Data_Sf,\n  sigma_type = \"ppl\",  # Can change to \"scott\", \"diggle\", or \"ppl\"\n  kernel_method = \"epanechnikov\"  # Can change to \"epanechnikov\", \"quartic\", or others\n)\n\n\nYangon_Results_PPL_Epanechnikov_visualizations &lt;- visualize_conflict_results(Yangon_Results_PPL_Epanechnikov, \"Yangon\", \"PPL\", \"Epanechnikov\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n7.3.1.3 Analysis and Interpretation.\n\nWe used Scott’s bandwidth and the Epanechnikov kernel to model the spatial distribution of civilian conflicts in Yangon from 2021 to 2024. Scott’s method provides an optimal balance between bias and variance, ensuring smoother KDE without losing significant details. The Epanechnikov kernel minimizes error and focuses on areas with higher density, effectively capturing conflict hotspots while reducing the impact of outliers.\nKey Observations:\n\nCentral Yangon Hotspot: Conflict density remains consistently high in central Yangon throughout the period.\nTemporal Shifts: Conflict intensity fluctuates across quarters, peaking in certain periods (e.g., Q3-2022 and Q1-2024), with some spread into surrounding areas over time.\nDensity Spread: While central areas remain the most affected, the gradual spread suggests an intensification or expansion of conflicts.\n\nIn summary, Scott’s bandwidth and the Epanechnikov kernel provided a precise view of conflict clustering and temporal changes, revealing critical patterns in civilian-related conflict hotspots in Yangon.\n\n\n\n7.3.2 Mandalay\n\n7.3.2.1 Mandalay Kernel 1: Gaussian Kernel\n\nDiggleScottCvLPPL\n\n\n\nMandalay_Results_Diggle_Gaussian &lt;- process_quarter_conflicts(\n  region_sf = Mandalay_Sf,\n  region_window = Mandalay_Owin,\n  region_name = \"Mandalay\",\n  data_sf = Mandalay_ACLED_Data_Sf,\n  sigma_type = \"diggle\",  # Can change to \"scott\", \"diggle\", or \"ppl\"\n  kernel_method = \"gaussian\"  # Can change to \"epanechnikov\", \"quartic\", or others\n)\n\n\nMandalay_Results_Diggle_Gaussian_visualizations &lt;- visualize_conflict_results(Mandalay_Results_Diggle_Gaussian, \"Mandalay\", \"Diggle\", \"Gaussian\")\n\n\n\n\n\n\n\n\n\n\n\nMandalay_Results_Scott_Gaussian &lt;- process_quarter_conflicts(\n  region_sf = Mandalay_Sf,\n  region_window = Mandalay_Owin,\n  region_name = \"Mandalay\",\n  data_sf = Mandalay_ACLED_Data_Sf,\n  sigma_type = \"scott\",  # Can change to \"scott\", \"diggle\", or \"ppl\"\n  kernel_method = \"gaussian\"  # Can change to \"epanechnikov\", \"quartic\", or others\n)\n\n\nMandalay_Results_Scott_Gaussian_visualizations &lt;- visualize_conflict_results(Mandalay_Results_Scott_Gaussian, \"Mandalay\", \"Scott\", \"Gaussian\")\n\n\n\n\n\n\n\n\n\n\n\nMandalay_Results_CvL_Gaussian &lt;- process_quarter_conflicts(\n  region_sf = Mandalay_Sf,\n  region_window = Mandalay_Owin,\n  region_name = \"Mandalay\",\n  data_sf = Mandalay_ACLED_Data_Sf,\n  sigma_type = \"cvl\",  # Can change to \"scott\", \"diggle\", or \"ppl\"\n  kernel_method = \"gaussian\"  # Can change to \"epanechnikov\", \"quartic\", or others\n)\n\n\nMandalay_Results_CvL_Gaussian_visualizations &lt;- visualize_conflict_results(Mandalay_Results_CvL_Gaussian, \"Mandalay\", \"CvL\", \"Gaussian\")\n\n\n\n\n\n\n\n\n\n\n\nMandalay_Results_PPL_Gaussian &lt;- process_quarter_conflicts(\n  region_sf = Mandalay_Sf,\n  region_window = Mandalay_Owin,\n  region_name = \"Mandalay\",\n  data_sf = Mandalay_ACLED_Data_Sf,\n  sigma_type = \"ppl\",  # Can change to \"scott\", \"diggle\", or \"ppl\"\n  kernel_method = \"gaussian\"  # Can change to \"epanechnikov\", \"quartic\", or others\n)\n\n\nMandalay_Results_PPL_Gaussian_visualizations &lt;- visualize_conflict_results(Mandalay_Results_PPL_Gaussian, \"Mandalay\", \"PPL\", \"Gaussian\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n7.3.2.2 Mandalay Kernel 2: Epanechnikov Kernel\n\nDiggleScottCvLPPL\n\n\n\nMandalay_Results_Diggle_Epanechnikov &lt;- process_quarter_conflicts(\n  region_sf = Mandalay_Sf,\n  region_window = Mandalay_Owin,\n  region_name = \"Mandalay\",\n  data_sf = Mandalay_ACLED_Data_Sf,\n  sigma_type = \"diggle\",  # Can change to \"scott\", \"diggle\", or \"ppl\"\n  kernel_method = \"epanechnikov\"  # Can change to \"epanechnikov\", \"quartic\", or others\n)\n\n\nMandalay_Results_Diggle_Epanechnikov_visualizations &lt;- visualize_conflict_results(Mandalay_Results_Diggle_Epanechnikov, \"Mandalay \", \"Diggle\", \"Epanechnikov\")\n\n\n\n\n\n\n\n\n\n\n\nMandalay_Results_Scott_Epanechnikov &lt;- process_quarter_conflicts(\n  region_sf = Mandalay_Sf,\n  region_window = Mandalay_Owin,\n  region_name = \"Mandalay\",\n  data_sf = Mandalay_ACLED_Data_Sf,\n  sigma_type = \"scott\",  # Can change to \"scott\", \"diggle\", or \"ppl\"\n  kernel_method = \"epanechnikov\"  # Can change to \"epanechnikov\", \"quartic\", or others\n)\n\n\nMandalay_Results_Scott_Epanechnikov_visualizations &lt;- visualize_conflict_results(Mandalay_Results_Scott_Epanechnikov, \"Mandalay \", \"Scott\", \"Epanechnikov\")\n\n\n\n\n\n\n\n\n\n\n\nMandalay_Results_CvL_Epanechnikov &lt;- process_quarter_conflicts(\n  region_sf = Mandalay_Sf,\n  region_window = Mandalay_Owin,\n  region_name = \"Mandalay \",\n  data_sf = Mandalay_ACLED_Data_Sf,\n  sigma_type = \"cvl\",  # Can change to \"scott\", \"diggle\", or \"ppl\"\n  kernel_method = \"epanechnikov\"  # Can change to \"epanechnikov\", \"quartic\", or others\n)\n\n\nMandalay_Results_CvL_Epanechnikov_visualizations &lt;- visualize_conflict_results(Mandalay_Results_CvL_Epanechnikov, \"Mandalay \", \"CvL\", \"Epanechnikov\")\n\n\n\n\n\n\n\n\n\n\n\nMandalay_Results_PPL_Epanechnikov &lt;- process_quarter_conflicts(\n  region_sf = Mandalay_Sf,\n  region_window = Mandalay_Owin,\n  region_name = \"Mandalay\",\n  data_sf = Mandalay_ACLED_Data_Sf,\n  sigma_type = \"ppl\",  # Can change to \"scott\", \"diggle\", or \"ppl\"\n  kernel_method = \"epanechnikov\"  # Can change to \"epanechnikov\", \"quartic\", or others\n)\n\n\nMandalay_Results_PPL_Epanechnikov_visualizations &lt;- visualize_conflict_results(Mandalay_Results_PPL_Epanechnikov, \"Mandalay \", \"PPL\", \"Epanechnikov\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n7.3.2.3 Analysis and Interpretation\n\nWe applied Scott’s bandwidth and the Epanechnikov kernel for the Mandalay civilian conflict KDE, as it provides optimal smoothing and reduces variance. The kernel effectively focuses on dense areas, capturing conflict intensity over time without distortion from outliers.\nKey Observations:\n\nCentral Mandalay Hotspot: Consistent conflict density is observed in central Mandalay across all quarters, with peaks in Q3-2022 and Q1-2023.\nSpatiotemporal Patterns: Conflict density fluctuates quarter by quarter, with spread toward the north in several periods, indicating shifts in conflict zones.\nStability vs Spread: While central Mandalay remains a key hotspot, the spread of conflicts over time suggests areas of emerging concern.\n\nThis KDE approach reveals both stable hotspots and the evolving nature of conflicts in Mandalay, providing insights into the intensity and movement of conflict zones across different periods.\n\n\n\n7.3.3 Sagaing\n\n7.3.3.1 Sagaing Kernel 1: Gaussian Kernel\n\nDiggleScottCvLPPL\n\n\n\nSagaing_Results_Diggle_Gaussian &lt;- process_quarter_conflicts(\n  region_sf = Sagaing_Sf,\n  region_window = Sagaing_Owin,\n  region_name = \"Sagaing\",\n  data_sf = Sagaing_ACLED_Data_Sf,\n  sigma_type = \"diggle\",  # Can change to \"scott\", \"diggle\", or \"ppl\"\n  kernel_method = \"gaussian\"  # Can change to \"epanechnikov\", \"quartic\", or others\n)\n\n\nSagaing_Results_Diggle_Gaussian_visualizations &lt;- visualize_conflict_results(Sagaing_Results_Diggle_Gaussian, \"Sagaing\", \"Diggle\", \"Gaussian\")\n\n\n\n\n\n\n\n\n\n\n\nSagaing_Results_Scott_Gaussian &lt;- process_quarter_conflicts(\n  region_sf = Sagaing_Sf,\n  region_window = Sagaing_Owin,\n  region_name = \"Sagaing\",\n  data_sf = Sagaing_ACLED_Data_Sf,\n  sigma_type = \"scott\",  # Can change to \"scott\", \"diggle\", or \"ppl\"\n  kernel_method = \"gaussian\"  # Can change to \"epanechnikov\", \"quartic\", or others\n)\n\n\nSagaing_Results_Scott_Gaussian_visualizations &lt;- visualize_conflict_results(Sagaing_Results_Scott_Gaussian, \"Sagaing\", \"Scott\", \"Gaussian\")\n\n\n\n\n\n\n\n\n\n\n\nSagaing_Results_CVL_Gaussian &lt;- process_quarter_conflicts(\n  region_sf = Sagaing_Sf,\n  region_window = Sagaing_Owin,\n  region_name = \"Sagaing\",\n  data_sf = Sagaing_ACLED_Data_Sf,\n  sigma_type = \"cvl\",  # Can change to \"scott\", \"diggle\", or \"ppl\"\n  kernel_method = \"gaussian\"  # Can change to \"epanechnikov\", \"quartic\", or others\n)\n\n\nSagaing_Results_CVL_Gaussian_visualizations &lt;- visualize_conflict_results(Sagaing_Results_CVL_Gaussian, \"Sagaing\", \"CVL\", \"Gaussian\")\n\n\n\n\n\n\n\n\n\n\n\nSagaing_Results_PPL_Gaussian &lt;- process_quarter_conflicts(\n  region_sf = Sagaing_Sf,\n  region_window = Sagaing_Owin,\n  region_name = \"Sagaing\",\n  data_sf = Sagaing_ACLED_Data_Sf,\n  sigma_type = \"ppl\",  # Can change to \"scott\", \"diggle\", or \"ppl\"\n  kernel_method = \"gaussian\"  # Can change to \"epanechnikov\", \"quartic\", or others\n)\n\n\nSagaing_Results_PPL_Gaussian_visualizations &lt;- visualize_conflict_results(Sagaing_Results_PPL_Gaussian, \"Sagaing\", \"PPL\", \"Gaussian\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n7.3.3.2 Sagaing Kernel 2: Epanechnikov Kernel\n\nDiggleScottCvLPPL\n\n\n\nSagaing_Results_Diggle_Epanechnikov &lt;- process_quarter_conflicts(\n  region_sf = Sagaing_Sf,\n  region_window = Sagaing_Owin,\n  region_name = \"Sagaing\",\n  data_sf = Sagaing_ACLED_Data_Sf,\n  sigma_type = \"diggle\",  # Can change to \"scott\", \"diggle\", or \"ppl\"\n  kernel_method = \"epanechnikov\"  # Can change to \"epanechnikov\", \"quartic\", or others\n)\n\n\nSagaing_Results_Diggle_Epanechnikov_visualizations &lt;- visualize_conflict_results(Sagaing_Results_Diggle_Epanechnikov, \"Sagaing\", \"Diggle\", \"Epanechnikov\")\n\n\n\n\n\n\n\n\n\n\n\nSagaing_Results_Scott_Epanechnikov &lt;- process_quarter_conflicts(\n  region_sf = Sagaing_Sf,\n  region_window = Sagaing_Owin,\n  region_name = \"Sagaing\",\n  data_sf = Sagaing_ACLED_Data_Sf,\n  sigma_type = \"scott\",  # Can change to \"scott\", \"diggle\", or \"ppl\"\n  kernel_method = \"epanechnikov\"  # Can change to \"epanechnikov\", \"quartic\", or others\n)\n\n\nSagaing_Results_Scott_Epanechnikov_visualizations &lt;- visualize_conflict_results(Sagaing_Results_Scott_Epanechnikov, \"Sagaing\", \"Scott\", \"Epanechnikov\")\n\n\n\n\n\n\n\n\n\n\n\nSagaing_Results_Cvl_Epanechnikov &lt;- process_quarter_conflicts(\n  region_sf = Sagaing_Sf,\n  region_window = Sagaing_Owin,\n  region_name = \"Sagaing\",\n  data_sf = Sagaing_ACLED_Data_Sf,\n  sigma_type = \"cvl\",  # Can change to \"scott\", \"diggle\", or \"ppl\"\n  kernel_method = \"epanechnikov\"  # Can change to \"epanechnikov\", \"quartic\", or others\n)\n\n\nSagaing_Results_CvL_Epanechnikov_visualizations &lt;- visualize_conflict_results(Sagaing_Results_Cvl_Epanechnikov, \"Sagaing\", \"CvL\", \"Epanechnikov\")\n\n\n\n\n\n\n\n\n\n\n\nSagaing_Results_PPL_Epanechnikov &lt;- process_quarter_conflicts(\n  region_sf = Sagaing_Sf,\n  region_window = Sagaing_Owin,\n  region_name = \"Sagaing\",\n  data_sf = Sagaing_ACLED_Data_Sf,\n  sigma_type = \"ppl\",  # Can change to \"scott\", \"diggle\", or \"ppl\"\n  kernel_method = \"epanechnikov\"  # Can change to \"epanechnikov\", \"quartic\", or others\n)\n\n\nSagaing_Results_PPL_Epanechnikov_visualizations &lt;- visualize_conflict_results(Sagaing_Results_PPL_Epanechnikov, \"Sagaing\", \"PPL\", \"Epanechnikov\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n7.3.3.3 Analysis and Interpretation\n\nIn Sagaing, we again utilized Scott’s bandwidth and the Epanechnikov kernel for KDE to assess the spatiotemporal distribution of civilian conflict events. This method ensures that key dense areas are well-represented while minimizing the impact of noise from less significant areas.\nKey Observations:\n\nConsistent Hotspot: The southern region of Sagaing consistently shows high-density conflict areas throughout the quarters, especially peaking during Q3-2022 and Q1-2023.\nEmerging Zones: Some quarters, such as Q1-2022 and Q3-2023, show increased conflict spread to the north, indicating a potential shift in conflict locations.\nStability and Peaks: The core conflict areas maintain their intensity, while certain periods experience an expansion of conflict areas, with a notable rise in density during the mid-2022 period.\n\nThese patterns highlight that conflict zones in Sagaing are relatively stable with periods of increased intensity, particularly in southern areas. This provides critical insights into when and where civilian conflict events have intensified."
  },
  {
    "objectID": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#yangon-6",
    "href": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#yangon-6",
    "title": "Take_Home Exercise 1: Geospatial Analytics for Social Good: Application of Spatial and Spatio-temporal Point Patterns Analysis to discover the geographical distribution of Armed Conflict in Myanmar",
    "section": "8.1 Yangon",
    "text": "8.1 Yangon\nFor the Yangon conflict events, we’ll perform a detailed spatial point pattern analysis using the Clark-Evans test, Ripley’s K-function, and L-function. This will help us understand whether the conflict events are randomly distributed, clustered, or dispersed, and at what scales clustering occurs.\n\nNull and Alternative Hypothesis:\n\nHo (Null Hypothesis): The distribution of civilian-related conflicts in Yangon is randomly distributed (CSR: Complete Spatial Randomness).\nH1 (Alternative Hypothesis): The distribution of civilian-related conflicts in Yangon is not randomly distributed (it is clustered or dispersed).\n\n\n\n8.1.1 Yangon’s Clark and Evan Test\n\n# Perform the Clark-Evans test for clustering\nYangon_ClarksEvan &lt;- clarkevans.test(Yangon_ACLED_ppp, \n                                      correction = \"none\", \n                                      clipregion = Yangon_Owin, \n                                      alternative = c(\"clustered\"),\n                                      nsim = 30)\n\n# Print Clark-Evans p-value and R-statistic\nprint(Yangon_ClarksEvan)\n\n\n    Clark-Evans test\n    No edge correction\n    Z-test\n\ndata:  Yangon_ACLED_ppp\nR = 0.11849, p-value &lt; 2.2e-16\nalternative hypothesis: clustered (R &lt; 1)\n\n\n\n\n8.1.2 Yangon’s K-Function Method\n\nK-FunctionEnvelope Test\n\n\n\nK_Yangon &lt;- Kest(Yangon_ACLED_ppp, correction = \"Ripley\")\n\n\n# Step 2: Plot the K-function, showing K(d) - r\nplot(K_Yangon, . -r ~ r, ylab = \"K(d) - r\", xlab = \"d(KM)\", main = \"Ripley's K-Function for Yangon Civilian Related Conflicts\")\n\n\n\n\n\n\n\n\n\n\n\nK_Yangon_CSR &lt;- envelope(Yangon_ACLED_ppp, Kest, nsim = 30, rank = 1, global = TRUE)\n\n\nplot(K_Yangon_CSR, . - r ~ r, xlab = \"d(KM\", ylab = \"K(d) - r\", main = \"Envelope for K-Function (CSR) - Yangon Civilian Related Conflicts\")\n\n\n\n\n\n\n\n\n\n\n\n\n8.1.2.2 Yangon’s K-Function Method Observation Table\n\n# Step 1: Define key distances (e.g., 20000m, 30000m, 40000m)\nkey_distances &lt;- c(5, 10, 15,20,25)\n\n# Step 2: Extract observed K-function values and CSR bounds at distances closest to key distances\nclosest_indices &lt;- sapply(key_distances, function(d) which.min(abs(K_Yangon_CSR$r - d)))\n\n# Step 3: Create a table summarizing observed and CSR envelope bounds at the closest distances\nobserved_table &lt;- data.frame(\n  Distance = K_Yangon_CSR$r[closest_indices],       # Actual distances used in the analysis\n  K_Obs = K_Yangon_CSR$obs[closest_indices],        # Observed K-function values\n  K_Lo = K_Yangon_CSR$lo[closest_indices],          # Lower bound of CSR envelope\n  K_Hi = K_Yangon_CSR$hi[closest_indices]           # Upper bound of CSR envelope\n)\n\n# Display the observed table\nprint(observed_table)\n\n  Distance     K_Obs       K_Lo      K_Hi\n1  4.99309  1822.917   35.71503  120.9307\n2  9.98618  5226.240  270.68366  355.8994\n3 14.97927  8118.862  662.29805  747.5137\n4 20.02663  9683.831 1217.37812 1302.5938\n5 25.01972 10687.263 1923.98668 2009.2024\n\n\n\n\n\n8.1.2 Yangon’s L Functions\n\nL FunctionEnvelope Test\n\n\n\nL_Yangon &lt;- Lest(Yangon_ACLED_ppp, correction = \"Ripley\")\n\n\nplot(L_Yangon, . -r ~ r, ylab = \"L(d) - r\", xlab = \"d(KM)\", main = \"Ripley's L-Function for Yangon Civilian Related Conflicts\")\n\n\n\n\n\n\n\n\n\n\n\nL_Yangon_CSR &lt;- envelope(Yangon_ACLED_ppp, Lest, nsim = 30, rank = 1, global = TRUE, savefuns = TRUE)\n\n\nplot(L_Yangon_CSR, . - r ~ r, xlab = \"d(km)\", ylab = \"L(d) - r\", main = \"Envelope for L-Function (CSR) - Yangon Civilian Related Conflicts\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n8.1.2.2 Yangon’s L Functions Observation Table\n\nkey_distances &lt;- c(5, 10, 15,20,25)\n# Step 2: Extract observed K-function values and CSR bounds at distances closest to key distances\nclosest_indices &lt;- sapply(key_distances, function(d) which.min(abs(L_Yangon_CSR$r - d)))\n# Step 3: Create a table summarizing observed and CSR envelope bounds at the closest distances\nobserved_table &lt;- data.frame(\n  Distance = L_Yangon_CSR$r[closest_indices],       # Actual distances used in the analysis\n  L_Obs = L_Yangon_CSR$obs[closest_indices],        # Observed K-function values\n  L_Lo = L_Yangon_CSR$lo[closest_indices],          # Lower bound of CSR envelope\n  L_Hi = L_Yangon_CSR$hi[closest_indices]           # Upper bound of CSR envelope\n)\n# Display the observed table\nprint(observed_table)\n\n  Distance    L_Obs      L_Lo      L_Hi\n1  4.99309 24.08843  4.836161  5.150019\n2  9.98618 40.78681  9.829251 10.143108\n3 14.97927 50.83615 14.822341 15.136198\n4 20.02663 55.51990 19.869703 20.183561\n5 25.01972 58.32548 24.862793 25.176651\n\n\n\n\n8.1.4 Yangons- Analysis and Interpretation\nBased on the analysis of the Clark-Evans test, K-function, and L-function, we can draw the following conclusions:\n\nClark-Evans Test:\n\nR = 0.099924, p-value &lt; 2.2e-16 . The R-value is less than 1, and the p-value is very small, which means the civilian related conflict events in Yangon are not randomly distributed and are significantly clustered.\n\nK-function Analysis:\n\n\nThe observed K-function consistently exceeds the upper bound of the CSR envelope across all distances, indicating that the clustering is prominent over a wide range of distances (up to 25km). The clustering becomes more pronounced as the distance increases.\n\nL-function Analysis:\nx\n\nThe observed L-function also exceeds the CSR envelope’s upper bounds, confirming the presence of clustering at multiple spatial scales. This supports the findings from the K-function.\n\n\nObserved Tables:\n\n\n\n\n\n\n\n\n\n\n\n\nDistance\nK_Obs\nK_Lo\nK_Hi\nL_OBV\nL_Lo\nL_Hi\n\n\n\n\n4.99309\n1822.917\n35.71503\n120.9307\n24.0883\n4.836161\n5.150019\n\n\n9.98618\n5226.240\n270.68366\n355.8994\n40.78681\n9.829251\n10.14311\n\n\n14.97927\n8118.682\n662.29806\n747.5137\n50.83615\n14.82234\n15.1362\n\n\n20.02663\n9683.831\n1217.37812\n1302.5938\n55.5199\n19.8697\n20.18356\n\n\n25.01972\n10687.263\n1923.98668\n2009.202\n53.32548\n24.86279\n25.17665\n\n\n\n\nThe observed K-function and L-function tables confirm that the observed values are significantly higher than the expected values under CSR, particularly at distances of 5km, 10km, 15km, and beyond, suggesting clustering at larger spatial scales.\n\n\n\nWe reject the null hypothesis of Complete Spatial Randomness (CSR) for Yangon civilian-related conflicts. The Clark-Evans test shows significant clustering, and both the K-function and L-function support this finding by indicating clustering over a broad range of distances. The observed tables further confirm this, as the observed values consistently exceed the CSR bounds. Therefore, the civilian conflict events in Yangon are significantly clustered rather than randomly distributed."
  },
  {
    "objectID": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#mandalay-6",
    "href": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#mandalay-6",
    "title": "Take_Home Exercise 1: Geospatial Analytics for Social Good: Application of Spatial and Spatio-temporal Point Patterns Analysis to discover the geographical distribution of Armed Conflict in Myanmar",
    "section": "8.2 Mandalay",
    "text": "8.2 Mandalay\nFor the Mandalay conflict events, we’ll perform a detailed spatial point pattern analysis using the Clark-Evans test, Ripley’s K-function, and L-function. This will help us understand whether the conflict events are randomly distributed, clustered, or dispersed, and at what scales clustering occurs.\n\nNull and Alternative Hypothesis:\n\nHo (Null Hypothesis): The distribution of civilian-related conflicts in Mandalay is randomly distributed (CSR: Complete Spatial Randomness).\nH1 (Alternative Hypothesis): The distribution of civilian-related conflicts in Mandalay is not randomly distributed (it is clustered or dispersed).\n\n\n\n8.2.1 Clarks Evan Test\n\n# Perform the Clark-Evans test for clustering\nMandalay_ClarksEvan &lt;- clarkevans.test(Mandalay_ACLED_ppp, \n                              correction = \"none\", \n                              clipregion = Mandalay_Owin, \n                              alternative = c(\"clustered\"),\n                              nsim = 30)\n# Print Clark-Evans p-value and R-statistic\nprint(Mandalay_ClarksEvan)\n\n\n    Clark-Evans test\n    No edge correction\n    Z-test\n\ndata:  Mandalay_ACLED_ppp\nR = 0.2192, p-value &lt; 2.2e-16\nalternative hypothesis: clustered (R &lt; 1)\n\n\n\n\n8.2.2 K Function\n\nK-Function DataK-Function Envelope Test\n\n\n\nK_Mandalay &lt;- Kest(Mandalay_ACLED_ppp, correction = \"Ripley\")\n\n\nplot(K_Mandalay, . -r ~ r, ylab = \"K(d) - r\", xlab = \"d(KM)\", main = \"Ripley's K-Function for Mandalay Civilian Related Conflicts\")\n\n\n\n\n\n\n\n\n\n\n\nK_Mandalay_CSR &lt;- envelope(Mandalay_ACLED_ppp, Kest, nsim = 30, rank = 1, global = TRUE)\n\n\nplot(K_Mandalay_CSR, . -r ~ r, ylab = \"K(d) - r\", xlab = \"d(Km)\", main = \"Ripley's K-Function for Mandalay Civilian Related Conflicts\")\n\n\n\n\n\n\n\n\n\n\n\n\n8.2.2.2 Observed Table (K-Function at Key Distances)\n\n# Step 1: Define key distances (e.g., 20000m, 30000m, 40000m)\nkey_distances &lt;- c(10,20,30,40)\n\n# Step 2: Extract observed K-function values and CSR bounds at distances closest to key distances\nclosest_indices &lt;- sapply(key_distances, function(d) which.min(abs(K_Mandalay_CSR$r - d)))\n\n# Step 3: Create a table summarizing observed and CSR envelope bounds at the closest distances\nobserved_table &lt;- data.frame(\n  Distance = K_Mandalay_CSR$r[closest_indices],       # Actual distances used in the analysis\n  K_Obs = K_Mandalay_CSR$obs[closest_indices],        # Observed K-function values\n  K_Lo = K_Mandalay_CSR$lo[closest_indices],          # Lower bound of CSR envelope\n  K_Hi = K_Mandalay_CSR$hi[closest_indices]           # Upper bound of CSR envelope\n)\n\n# Display the observed table\nprint(observed_table)\n\n   Distance     K_Obs      K_Lo      K_Hi\n1  9.962643  7305.334  260.9636  362.6693\n2 20.016687 10852.795 1207.8820 1309.5878\n3 29.979331 15847.857 2772.6858 2874.3915\n4 40.033374 21114.336 4984.0867 5085.7925\n\n\n\n\n\n8.2.3 L Function\n\nMandalay L FunctionMandalay Envelope Test\n\n\n\nL_Mandalay &lt;- Lest(Mandalay_ACLED_ppp, correction = \"Ripley\")\n\n\nplot(L_Mandalay, . -r ~ r, ylab = \"L(d) - r\", xlab = \"d(KM)\", main = \"Ripley's L-Function for Mandalay Civilian Related Conflicts\")\n\n\n\n\n\n\n\n\n\n\n\nL_Mandalay_CSR &lt;- envelope(Mandalay_ACLED_ppp, Lest, nsim = 30, rank = 1, global = TRUE, savefuns = TRUE)\n\n\nplot(L_Mandalay_CSR, . - r ~ r, xlab = \"d(KM)\", ylab = \"L(d) - r\", main = \"Envelope for L-Function (CSR) - Mandalay Civilian Related Conflicts\")\n\n\n\n\n\n\n\n\n\n\n\n\n8.2.3.2 Observed Table (L-Function at Key Distances)\n\nkey_distances &lt;- c(10,20,30,40)\n\n# Step 2: Extract observed K-function values and CSR bounds at distances closest to key distances\nclosest_indices &lt;- sapply(key_distances, function(d) which.min(abs(L_Mandalay_CSR$r - d)))\n\n# Step 3: Create a table summarizing observed and CSR envelope bounds at the closest distances\nobserved_table &lt;- data.frame(\n  Distance = L_Mandalay_CSR$r[closest_indices],       # Actual distances used in the analysis\n  L_Obs = L_Mandalay_CSR$obs[closest_indices],        # Observed K-function values\n  L_Lo = L_Mandalay_CSR$lo[closest_indices],          # Lower bound of CSR envelope\n  L_Hi = L_Mandalay_CSR$hi[closest_indices]           # Upper bound of CSR envelope\n)\n\n# Display the observed table\nprint(observed_table)\n\n   Distance    L_Obs      L_Lo     L_Hi\n1  9.962643 48.22199  9.689332 10.23595\n2 20.016687 58.77544 19.743376 20.29000\n3 29.979331 71.02485 29.706020 30.25264\n4 40.033374 81.98111 39.760063 40.30669\n\n\n\n\n\n8.2.4 Mandalay- Analysis and Interpretation\nBased on the analysis of the Clark-Evans test, K-function, and L-function, we can draw the following conclusions:\n\nClark-Evans Test:\n\nR = 0.14898, p-value &lt; 2.2e-16. The R-value is less than 1, and the p-value is very small, which means the civilian related conflict events in Mandalay are not randomly distributed and are significantly clustered.\n\nK-function Analysis:\n\n\nThe observed K-function consistently exceeds the upper bound of the CSR envelope across all distances, indicating that the clustering is prominent over a wide range of distances (up to 70km). The clustering becomes more pronounced as the distance increases.\n\nL-function Analysis:\n\n\nThe observed L-function also exceeds the CSR envelope’s upper bounds, confirming the presence of clustering at multiple spatial scales. This supports the findings from the K-function.\n\nObserved Tables:\n\n\n\n\n\n\n\n\n\n\n\n\n\nDistance\nK_Obs\nK_Lo\nK_Hi\nL_Obs\nL_Lo\nL_Hi\n\n\n\n\n9.962643\n7305.334\n260.9636\n362.6693\n48.22199\n9.689332\n10.23595\n\n\n20.016687\n10852.795\n1207.8820\n1309.5878\n58.77544\n19.743376\n20.2900\n\n\n29.979331\n15847.857\n2772.6858\n2874.3915\n71.02485\n29.706020\n30.25264\n\n\n40.033374\n21114.336\n4984.0867\n5085.7925\n81.9811\n39.760063\n40.30\n\n\n\n\nThe observed K-function and L-function tables confirm that the observed values are significantly higher than the expected values under CSR, particularly at distances of 20km, 30km, 40km, and beyond, suggesting clustering at larger spatial scales.\n\nWe reject the null hypothesis of Complete Spatial Randomness (CSR) for Mandalay civilian-related conflicts. The Clark-Evans test shows significant clustering, and both the K-function and L-function support this finding by indicating clustering over a broad range of distances. The observed tables further confirm this, as the observed values consistently exceed the CSR bounds. Therefore, the civilian conflict events in Mandalay are significantly clustered rather than randomly distributed."
  },
  {
    "objectID": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#sagaing-5",
    "href": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#sagaing-5",
    "title": "Take_Home Exercise 1: Geospatial Analytics for Social Good: Application of Spatial and Spatio-temporal Point Patterns Analysis to discover the geographical distribution of Armed Conflict in Myanmar",
    "section": "8.3 Sagaing",
    "text": "8.3 Sagaing\nFor the Sagaing conflict events, we’ll perform a detailed spatial point pattern analysis using the Clark-Evans test, Ripley’s K-function, and L-function. This will help us understand whether the conflict events are randomly distributed, clustered, or dispersed, and at what scales clustering occurs.\n\nNull and Alternative Hypothesis:\n\nHo (Null Hypothesis): The distribution of civilian-related conflicts in Sagaing is randomly distributed (CSR: Complete Spatial Randomness).\nH1 (Alternative Hypothesis): The distribution of civilian-related conflicts in Sagaing is not randomly distributed (it is clustered or dispersed).\n\n\n\n8.3.1 Clarks Evan Test\n\n# Perform the Clark-Evans test for clustering\nSagaing_ClarksEvan &lt;- clarkevans.test(Sagaing_ACLED_ppp, \n                              correction = \"none\", \n                              clipregion = Sagaing_Owin, \n                              alternative = c(\"clustered\"),\n                              nsim = 30)\n# Print Clark-Evans p-value and R-statistic\nprint(Sagaing_ClarksEvan)\n\n\n    Clark-Evans test\n    No edge correction\n    Z-test\n\ndata:  Sagaing_ACLED_ppp\nR = 0.1827, p-value &lt; 2.2e-16\nalternative hypothesis: clustered (R &lt; 1)\n\n\n\nK-Function MethodEnvelope Test\n\n\n\nK_Sagaing &lt;- Kest(Sagaing_ACLED_ppp, correction = \"Ripley\")\n\n\nplot(K_Sagaing, . -r ~ r, ylab = \"K(d) - r\", xlab = \"d(KM)\", main = \"Ripley's K-Function for Sagaing Civilian Related Conflicts\")\n\n\n\n\n\n\n\n\n\n\n\nK_Sagaing_CSR &lt;- envelope(Sagaing_ACLED_ppp, Kest, nsim = 30, rank = 1, global = TRUE)\n\n\nplot(K_Sagaing_CSR, . - r ~ r, xlab = \"d(KM)\", ylab = \"K(d) - r\", main = \"Envelope for K-Function (CSR) - Sagaing Conflicts\")\n\n\n\n\n\n\n\n\n\n\n\n\n8.3.2.2 Observed Table (K-Function at Key Distances)\n\n# Step 1: Define key distances (e.g., 20000m, 30000m, 40000m)\nkey_distances &lt;- c(20,30,40,50,60,70)\n\n# Step 2: Extract observed K-function values and CSR bounds at distances closest to key distances\nclosest_indices &lt;- sapply(key_distances, function(d) which.min(abs(K_Sagaing_CSR$r - d)))\n\n# Step 3: Create a table summarizing observed and CSR envelope bounds at the closest distances\nobserved_table &lt;- data.frame(\n  Distance = K_Sagaing_CSR$r[closest_indices],       # Actual distances used in the analysis\n  K_Obs = K_Sagaing_CSR$obs[closest_indices],        # Observed K-function values\n  K_Lo = K_Sagaing_CSR$lo[closest_indices],          # Lower bound of CSR envelope\n  K_Hi = K_Sagaing_CSR$hi[closest_indices]           # Upper bound of CSR envelope\n)\n\n# Display the observed table\nprint(observed_table)\n\n  Distance     K_Obs      K_Lo      K_Hi\n1 19.99394  7021.421  1186.336  1325.415\n2 29.99091 12903.634  2756.181  2895.260\n3 39.98788 19530.590  4953.964  5093.043\n4 49.98485 26873.240  7779.685  7918.764\n5 59.98182 34286.168 11233.343 11372.422\n6 68.24599 40939.246 14562.475 14701.554\n\n\n\n\n\n8.3.3 L-Function Method\n\nL FunctionEnvelope Test\n\n\n\n# Step 1: Calculate the L-function (Ripley's L) for Sagaing conflicts\nL_Sagaing &lt;- Lest(Sagaing_ACLED_ppp, correction = \"Ripley\")\n\n\n# Step 2: Plot the L-function, showing L(d) - r\nplot(L_Sagaing, . - r ~ r, ylab = \"L(d) - r\", xlab = \"d(km)\", main = \"Ripley's L-Function for Sagaing Civilian Related Conflicts\")\n\n\n\n\n\n\n\n\n\n\n\nL_Sagaing_CSR &lt;- envelope(Sagaing_ACLED_ppp, Lest, nsim = 30, rank = 1, global = TRUE)\n\n\nplot(L_Sagaing_CSR, . - r ~ r, xlab = \"d(KM)\", ylab = \"K(d) - r\", main = \"Envelope for L-Function (CSR) - Sagaing Civilian Related Conflicts\")\n\n\n\n\n\n\n\n\n\n\n\n\n8.3.3.3 Observed Table (L-Function at Key Distances)\n\nkey_distances &lt;- c(20,30,40,50,60,70)\n\n# Step 2: Extract observed K-function values and CSR bounds at distances closest to key distances\nclosest_indices &lt;- sapply(key_distances, function(d) which.min(abs(L_Sagaing_CSR$r - d)))\n\n# Step 3: Create a table summarizing observed and CSR envelope bounds at the closest distances\nobserved_table &lt;- data.frame(\n  Distance = L_Sagaing_CSR$r[closest_indices],       # Actual distances used in the analysis\n  L_Obs = L_Sagaing_CSR$obs[closest_indices],        # Observed K-function values\n  L_Lo = L_Sagaing_CSR$lo[closest_indices],          # Lower bound of CSR envelope\n  L_Hi = L_Sagaing_CSR$hi[closest_indices]           # Upper bound of CSR envelope\n)\n\n# Display the observed table\nprint(observed_table)\n\n  Distance     L_Obs     L_Lo     L_Hi\n1 19.99394  47.27566 19.81300 20.17488\n2 29.99091  64.08864 29.80997 30.17185\n3 39.98788  78.84656 39.80694 40.16882\n4 49.98485  92.48793 49.80391 50.16579\n5 59.98182 104.46830 59.80088 60.16277\n6 68.24599 114.15501 68.06505 68.42693\n\n\n\n\n\n8.3.4 Sagaing - Analysis and Interpretation\nBased on the analysis of the Clark-Evans test, K-function, and L-function, we can draw the following conclusions:\n\nClark-Evans Test:\n\nR = 0.1485, p-value &lt; 2.2e-16 . The R-value is less than 1, and the p-value is very small, which means the conflict events in Sagaing are not randomly distributed and are significantly clustered.\n\nK-function Analysis:\n\n\nThe observed K-function consistently exceeds the upper bound of the CSR envelope across all distances, indicating that the clustering is prominent over a wide range of distances (up to 70km). The clustering becomes more pronounced as the distance increases.\n\nL-function Analysis:\n\n\nThe observed L-function also exceeds the CSR envelope’s upper bounds, confirming the presence of clustering at multiple spatial scales. This supports the findings from the K-function.\n\nObserved Tables:\n\n\n\n\n\n\n\n\n\n\n\n\n\nDistance\nK_Obs\nK_Lo\nK_Hi\nL_Obs\nL_Lo\nL_Hi\n\n\n\n\n19.99394\n7021.421\n1186.336\n1325.415\n19.81300\n20.17488\n20.17488\n\n\n29.99091\n12903.634\n2756.181\n2895.260\n64.08864\n29.80997\n30.17185\n\n\n39.98788\n19530.590\n4963.964\n5093.043\n78.84656\n39.80694\n40.16882\n\n\n49.98485\n26873.240\n7797.685\n7916.764\n92.48793\n49.80391\n50.16579\n\n\n59.98182\n34286.168\n11233.343\n11372.422\n104.46830\n59.80088\n60.16277\n\n\n68.24599\n40939.246\n1456,475\n14701.554\n114.15501\n68.06505\n68.4269\n\n\n\n\nThe observed K-function and L-function tables confirm that the observed values are significantly higher than the expected values under CSR, particularly at distances of 20km, 30km, 40km, and beyond, suggesting clustering at larger spatial scales.\n\nWe reject the null hypothesis of Complete Spatial Randomness (CSR) for Sagaing civilian-related conflicts. The Clark-Evans test shows significant clustering, and both the K-function and L-function support this finding by indicating clustering over a broad range of distances. The observed tables further confirm this, as the observed values consistently exceed the CSR bounds. Therefore, the conflict events in Sagaing are significantly clustered rather than randomly distributed."
  },
  {
    "objectID": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#steps-for-code-breakdown.",
    "href": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#steps-for-code-breakdown.",
    "title": "Take_Home Exercise 1: Geospatial Analytics for Social Good: Application of Spatial and Spatio-temporal Point Patterns Analysis to discover the geographical distribution of Armed Conflict in Myanmar",
    "section": "9.1 Steps for code Breakdown.",
    "text": "9.1 Steps for code Breakdown.\n\nStep 1: Convert data to sf object to ensure compatibility for spatial analysis.\nStep 2: Extract longitude and latitude from the geometry column for plotting and analysis.\nStep 3: Create numeric and factor representations of quarters for time-based KDE and distinct plotting.\nStep 4: Generate a point pattern object (ppp) for spatial analysis with quarter factors as marks.\nStep 5: Assign circle sizes to each quarter for visual differentiation.\nStep 6: Plot the base map (Yangon) without data points.\nStep 7: Add points with sizes based on quarters to the map for visualization.\nStep 8: Add a legend to explain the circle sizes and quarters.\nStep 9: Create a numeric point pattern for KDE based on quarter information.\nStep 10: Perform KDE analysis on the spatio-temporal point pattern.\nStep 11: Define the quarters to be plotted for KDE analysis.\nStep 12: Set up a 4x4 plotting grid to display multiple KDE plots.\nStep 13: Loop through quarters and plot KDE layers for each, visualizing conflict intensity over time."
  },
  {
    "objectID": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#yangon-quarter-year-spatio-temporal-kde",
    "href": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#yangon-quarter-year-spatio-temporal-kde",
    "title": "Take_Home Exercise 1: Geospatial Analytics for Social Good: Application of Spatial and Spatio-temporal Point Patterns Analysis to discover the geographical distribution of Armed Conflict in Myanmar",
    "section": "9.2 Yangon Quarter Year Spatio-Temporal KDE",
    "text": "9.2 Yangon Quarter Year Spatio-Temporal KDE\n\nCode PreparationYangon Quarter Year OwinYangon Quarter Year KDEYangon Quarter Year KDE Animation And Analysis\n\n\n\n# Step 1: Ensure Yangon_QuarterYear_Sf is an sf object (if not already)\nYangon_QuarterYear_Sf &lt;- st_as_sf(Yangon_ACLED_Data_Sf)\n\n# Step 2: Extract the coordinates (longitude and latitude) from the geometry column\ncoords &lt;- st_coordinates(Yangon_QuarterYear_Sf)\n\n# Step 3: Convert quarter_numeric to factor for distinct quarters (for plotting the circles)\nYangon_QuarterYear_Sf &lt;- Yangon_QuarterYear_Sf %&gt;%\n  mutate(\n    year = as.numeric(sub(\".*-\", \"\", quarter_year)),                  # Extract the year (e.g., 2023)\n    quarter = as.numeric(sub(\"Q\", \"\", sub(\"-.*\", \"\", quarter_year))), # Extract the quarter (e.g., Q1 -&gt; 1)\n    \n    # Continuous representation of time (factor for distinct quarters)\n    quarter_numeric_factor = as.factor(year * 10 + quarter),  # Convert to factor for plotting the circles\n    quarter_numeric = year * 10 + quarter  # Keep as numeric for time-based KDE analysis\n  )\n\n# Step 4: Create the point pattern object using ppp() with factor marks (for distinct quarter plotting)\nYangon_QuarterYear_PPP_Factor &lt;- ppp(\n  x = coords[, 1],  # Longitude (x-coordinates)\n  y = coords[, 2],  # Latitude (y-coordinates)\n  window = Yangon_Owin,  # Spatial window (Yangon_Owin)\n  marks = Yangon_QuarterYear_Sf$quarter_numeric_factor  # Use factor for visualizing distinct quarters\n)\n\n\n# Step 5: Assign 14 unique sizes to the 14 unique quarter_numeric values\n# Create 14 different circle sizes, e.g., from 1 to 3 in size\nunique_quarters &lt;- levels(Yangon_QuarterYear_Sf$quarter_numeric_factor)  # Get the unique quarter levels (14 levels)\ncircle_sizes &lt;- seq(1, 3, length.out = length(unique_quarters))  # Generate 14 sizes from 1 to 3\n\n# Map each unique quarter_numeric level to a circle size\ncircle_size_map &lt;- setNames(circle_sizes, unique_quarters)  # Create a named vector to map quarter to size\n\n\n\n\n# Apply the circle size mapping to each point based on its quarter_numeric_factor\npoint_circle_sizes &lt;- circle_size_map[Yangon_QuarterYear_Sf$quarter_numeric_factor]\n\n# Step 6: Plot the base map (Yangon_Owin) without points\nplot(Yangon_Owin, main = \"Yangon Quarter-Year Owin with Unique Circle Sizes\")\n\n# Step 7: Add the points with the unique circle sizes based on quarter_numeric\npoints(coords[, 1], coords[, 2], cex = point_circle_sizes, pch = 16, col = \"black\")  # Add circles on top of base map\n\n# Step 8: Add a custom legend to show the quarter_numeric values and corresponding circle sizes\nlegend(\"topright\", legend = unique_quarters, \n       pch = 16, \n       pt.cex = circle_sizes,  # Show unique circle sizes in the legend\n       col = \"black\", \n       title = \"Quarters (Circle Size)\")\n\n\n\n\n\n\n\n\n\n\n\nYangon_QuarterYear_PPP_Numeric &lt;- ppp(\n  x = coords[, 1],  # Longitude (x-coordinates)\n  y = coords[, 2],  # Latitude (y-coordinates)\n  window = Yangon_Owin,  # Spatial window (Yangon_Owin)\n  marks = Yangon_QuarterYear_Sf$quarter_numeric  # Use numeric for KDE analysis (time-based)\n)\nYangon_QuarterYear_PPP_Numeric &lt;- rescale(Yangon_QuarterYear_PPP_Numeric, 1000, \"km\")\n\n\nYangon_QuarterYear_KDE &lt;- spattemp.density(Yangon_QuarterYear_PPP_Numeric)\n\nCalculating trivariate smooth...Done.\nEdge-correcting...Done.\nConditioning on time...Done.\n\nmulti_color_palette &lt;- colorRampPalette(c(\"blue\", \"green\", \"yellow\", \"red\"))\n\n\n# Define the quarters for which you want to plot the KDE\ntims &lt;- c(20211, 20212, 20213, 20214, 20221, 20222, 20223, 20224, \n          20231, 20232, 20233, 20234, 20241, 20242)\n\n#Set up the plotting window to display multiple plots in a grid (4 rows, 4 columns)\npar(mfrow=c(4, 4), mar=c(2, 2, 2, 2), oma=c(0, 0, 2, 0))  # Adjust margins and add outer margin for title\n\n# Loop through the 'tims' vector and plot the KDE for each time point (from left to right)\nfor(i in tims) { \n    plot(Yangon_QuarterYear_KDE, i, \n         override.par=FALSE,  # Keep the graphical parameters unchanged\n         fix.range=TRUE,      # Fix the range of the KDE\n         main=paste(\"Quarter\", i),  # Title for each plot\n         ribside = \"right\", \n         col = multi_color_palette(100))  # Use 'inferno' color gradient\n         \n    # Remove the x and y axis labels for a cleaner look\n    axis(1, labels=FALSE)\n    axis(2, labels=FALSE)\n}\n\n#dd a unified title across all plots (e.g., the duration of analysis)\nmtext(\"Quarterly Spatio-Temporal KDE for Civilian Conflict Intensity in Yangon\", \n      outer=TRUE, cex=1.5, font=2)\n\n\n\n\n\n\n\n\n\n\n\nmulti_color_palette &lt;- colorRampPalette(c(\"blue\", \"green\", \"yellow\", \"red\"))\n\n# Save the animation as a GIF\nsaveGIF({\n  # Loop over the valid quarter times\n  for(i in tims){ \n    suppressWarnings({\n      plot(Yangon_QuarterYear_KDE, i, \n           override.par=FALSE,  # Keep graphical parameters unchanged\n           fix.range=TRUE,      # Fix the range of the KDE\n           main=paste(\"Mandalay Civilian Related Conflict KDE at Quarter\", i),  # Title for each plot\n           ribside = \"right\",  # Legend on the right\n           col = multi_color_palette(100))  # Apply multi-color gradient\n    })\n  }\n}, movie.name = \"yangonkde_animation.gif\", interval = 0.5, ani.width = 800, ani.height = 800)\n\n\nIn Yangon, the spatio-temporal KDE analysis shows a reduction in overall conflict intensity from 2021 to 2024. However, it is important to note that while the intensity has decreased, clustering is still evident within the same few areas.\n\nKey Observations:\n\n2021 to 2022: Widespread high-intensity conflict areas in central Yangon are prominent in 2021 and early 2022, indicated by the larger red and orange zones.\n2023 to 2024: Although the intensity diminishes over time, the clustering remains persistent in specific areas. The high-intensity zones shrink, but they consistently appear in similar locations, suggesting that while the scale of conflict has reduced, these areas remain focal points for civilian conflict.\n\nThe persistent clustering, even as intensity diminishes, indicates that certain regions continue to experience conflicts, requiring targeted interventions in those zones."
  },
  {
    "objectID": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#mandalay-quarter-year-spatio-temporal-kde",
    "href": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#mandalay-quarter-year-spatio-temporal-kde",
    "title": "Take_Home Exercise 1: Geospatial Analytics for Social Good: Application of Spatial and Spatio-temporal Point Patterns Analysis to discover the geographical distribution of Armed Conflict in Myanmar",
    "section": "9.3 Mandalay Quarter Year Spatio-Temporal KDE",
    "text": "9.3 Mandalay Quarter Year Spatio-Temporal KDE\n\nMandalay Quarter Year Code PreparationMandalay Quarter Year OwinMandalay Quarter Year KDEMandalay Quarter Year KDE Animation And Analysis\n\n\n\n# Step 1: Ensure Mandalay_QuarterYear_Sf is an sf object (if not already)\nMandalay_QuarterYear_Sf &lt;- st_as_sf(Mandalay_ACLED_Data_Sf)\n\n# Step 2: Extract the coordinates (longitude and latitude) from the geometry column\ncoords &lt;- st_coordinates(Mandalay_QuarterYear_Sf)\n\n# Step 3: Convert quarter_numeric to factor for distinct quarters (for plotting the circles)\nMandalay_QuarterYear_Sf &lt;- Mandalay_QuarterYear_Sf %&gt;%\n  mutate(\n    year = as.numeric(sub(\".*-\", \"\", quarter_year)),                  # Extract the year (e.g., 2023)\n    quarter = as.numeric(sub(\"Q\", \"\", sub(\"-.*\", \"\", quarter_year))), # Extract the quarter (e.g., Q1 -&gt; 1)\n    \n    # Continuous representation of time (factor for distinct quarters)\n    quarter_numeric_factor = as.factor(year * 10 + quarter),  # Convert to factor for plotting the circles\n    quarter_numeric = year * 10 + quarter  # Keep as numeric for time-based KDE analysis\n  )\n\n# Step 4: Create the point pattern object using ppp() with factor marks (for distinct quarter plotting)\nMandalay_QuarterYear_PPP_Factor &lt;- ppp(\n  x = coords[, 1],  # Longitude (x-coordinates)\n  y = coords[, 2],  # Latitude (y-coordinates)\n  window = Mandalay_Owin,  # Spatial window (Mandalay_Owin)\n  marks = Mandalay_QuarterYear_Sf$quarter_numeric_factor  # Use factor for visualizing distinct quarters\n)\n\n\n# Step 5: Assign 14 unique sizes to the 14 unique quarter_numeric values\n# Create 14 different circle sizes, e.g., from 1 to 3 in size\nunique_quarters &lt;- levels(Mandalay_QuarterYear_Sf$quarter_numeric_factor)  # Get the unique quarter levels (14 levels)\ncircle_sizes &lt;- seq(1, 3, length.out = length(unique_quarters))  # Generate 14 sizes from 1 to 3\n\n# Map each unique quarter_numeric level to a circle size\ncircle_size_map &lt;- setNames(circle_sizes, unique_quarters)  # Create a named vector to map quarter to size\n\n\n\n\n# Apply the circle size mapping to each point based on its quarter_numeric_factor\npoint_circle_sizes &lt;- circle_size_map[Mandalay_QuarterYear_Sf$quarter_numeric_factor]\n\n# Step 6: Plot the base map (Mandalay_Owin) without points\nplot(Mandalay_Owin, main = \"Mandalay Quarter-Year Owin with Unique Circle Sizes\")\n\n# Step 7: Add the points with the unique circle sizes based on quarter_numeric\npoints(coords[, 1], coords[, 2], cex = point_circle_sizes, pch = 16, col = \"black\")  # Add circles on top of base map\n\n# Step 8: Add a custom legend to show the quarter_numeric values and corresponding circle sizes\nlegend(\"topright\", legend = unique_quarters, \n       pch = 16, \n       pt.cex = circle_sizes,  # Show unique circle sizes in the legend\n       col = \"black\", \n       title = \"Quarters (Circle Size)\")\n\n\n\n\n\n\n\n\n\n\n\nMandalay_QuarterYear_PPP_Numeric &lt;- ppp(\n  x = coords[, 1],  # Longitude (x-coordinates)\n  y = coords[, 2],  # Latitude (y-coordinates)\n  window = Mandalay_Owin,  # Spatial window (Mandalay_Owin)\n  marks = Mandalay_QuarterYear_Sf$quarter_numeric  # Use numeric for KDE analysis (time-based)\n)\n\nMandalay_QuarterYear_KDE &lt;- spattemp.density(Mandalay_QuarterYear_PPP_Numeric)\n\nCalculating trivariate smooth...Done.\nEdge-correcting...Done.\nConditioning on time...Done.\n\nmulti_color_palette &lt;- colorRampPalette(c(\"blue\", \"green\", \"yellow\", \"red\"))\n\n\n# Define the quarters for which you want to plot the KDE\ntims &lt;- c(20211, 20212, 20213, 20214, 20221, 20222, 20223, 20224, \n          20231, 20232, 20233, 20234, 20241, 20242)\n\n#Set up the plotting window to display multiple plots in a grid (4 rows, 4 columns)\npar(mfrow=c(4, 4), mar=c(2, 2, 2, 2), oma=c(0, 0, 2, 0))  # Adjust margins and add outer margin for title\n\n# Loop through the 'tims' vector and plot the KDE for each time point (from left to right)\nfor(i in tims) { \n  plot(Mandalay_QuarterYear_KDE, i, \n       override.par=FALSE,  # Keep the graphical parameters unchanged\n       fix.range=TRUE,      # Fix the range of the KDE\n       main=paste(\"Quarter\", i),  # Title for each plot\n       ribside = \"right\", \n       col = multi_color_palette(100))  # Use 'inferno' color gradient\n  \n  # Remove the x and y axis labels for a cleaner look\n  axis(1, labels=FALSE)\n  axis(2, labels=FALSE)\n}\n\n#dd a unified title across all plots (e.g., the duration of analysis)\nmtext(\"Quarterly Spatio-Temporal KDE for Civilian Conflict Intensity in Mandalay\", \n      outer=TRUE, cex=1.5, font=2)\n\n\n\n\n\n\n\n\n\n\n\nmulti_color_palette &lt;- colorRampPalette(c(\"blue\", \"green\", \"yellow\", \"red\"))\n\n# Save the animation as a GIF\nsaveGIF({\n  # Loop over the valid quarter times\n  for(i in tims){ \n    suppressWarnings({\n      plot(Mandalay_QuarterYear_KDE, i, \n           override.par=FALSE,  # Keep graphical parameters unchanged\n           fix.range=TRUE,      # Fix the range of the KDE\n           main=paste(\"Mandalay Civilian Related Conflict KDE at Quarter\", i),  # Title for each plot\n           ribside = \"right\",  # Legend on the right\n           col = multi_color_palette(100))  # Apply multi-color gradient\n    })\n  }\n}, movie.name = \"Mandalaykde_animation.gif\", interval = 0.5, ani.width = 800, ani.height = 800)\n\n\nIn Mandalay, the spatio-temporal KDE analysis similarly shows a general reduction in conflict intensity over time, from 2021 to 2024. However, like in Yangon, clustering remains within the same key areas across the quarters.\n\nKey Observations:\n\n2021 to 2022: High-intensity conflicts are concentrated in central and northern Mandalay, as shown by the red and orange clusters, particularly in early 2021 and 2022.\n2023 to 2024: The intensity of the conflicts decreases over time, but these clusters persist in similar regions, particularly in central Mandalay. This indicates that although conflict intensity is declining, these areas continue to be hotspots for civilian conflict.\n\nThus, the persistence of clustering in the same areas despite decreasing conflict intensity highlights the need for focused intervention strategies in these conflict-prone regions."
  },
  {
    "objectID": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#sagaing-quarter-year-spatio-temporal-kde",
    "href": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#sagaing-quarter-year-spatio-temporal-kde",
    "title": "Take_Home Exercise 1: Geospatial Analytics for Social Good: Application of Spatial and Spatio-temporal Point Patterns Analysis to discover the geographical distribution of Armed Conflict in Myanmar",
    "section": "9.4 Sagaing Quarter Year Spatio-Temporal KDE",
    "text": "9.4 Sagaing Quarter Year Spatio-Temporal KDE\n\nSagaing Quarter Year Code PreparationSagaing Quarter Year OwinSagaing Quarter Year KDESagaing Quarter Year KDE Animation\n\n\n\n# Step 1: Ensure Sagaing_QuarterYear_Sf is an sf object (if not already)\nSagaing_QuarterYear_Sf &lt;- st_as_sf(Sagaing_ACLED_Data_Sf)\n\n# Step 2: Extract the coordinates (longitude and latitude) from the geometry column\ncoords &lt;- st_coordinates(Sagaing_QuarterYear_Sf)\n\n# Step 3: Convert quarter_numeric to factor for distinct quarters (for plotting the circles)\nSagaing_QuarterYear_Sf &lt;- Sagaing_QuarterYear_Sf %&gt;%\n  mutate(\n    year = as.numeric(sub(\".*-\", \"\", quarter_year)),                  # Extract the year (e.g., 2023)\n    quarter = as.numeric(sub(\"Q\", \"\", sub(\"-.*\", \"\", quarter_year))), # Extract the quarter (e.g., Q1 -&gt; 1)\n    \n    # Continuous representation of time (factor for distinct quarters)\n    quarter_numeric_factor = as.factor(year * 10 + quarter),  # Convert to factor for plotting the circles\n    quarter_numeric = year * 10 + quarter  # Keep as numeric for time-based KDE analysis\n  )\n\n# Step 4: Create the point pattern object using ppp() with factor marks (for distinct quarter plotting)\nSagaing_QuarterYear_PPP_Factor &lt;- ppp(\n  x = coords[, 1],  # Longitude (x-coordinates)\n  y = coords[, 2],  # Latitude (y-coordinates)\n  window = Sagaing_Owin,  # Spatial window (Sagaing_Owin)\n  marks = Sagaing_QuarterYear_Sf$quarter_numeric_factor  # Use factor for visualizing distinct quarters\n)\n\n\n# Step 5: Assign 14 unique sizes to the 14 unique quarter_numeric values\n# Create 14 different circle sizes, e.g., from 1 to 3 in size\nunique_quarters &lt;- levels(Sagaing_QuarterYear_Sf$quarter_numeric_factor)  # Get the unique quarter levels (14 levels)\ncircle_sizes &lt;- seq(1, 3, length.out = length(unique_quarters))  # Generate 14 sizes from 1 to 3\n\n# Map each unique quarter_numeric level to a circle size\ncircle_size_map &lt;- setNames(circle_sizes, unique_quarters)  # Create a named vector to map quarter to size\n\n\n\n\n# Apply the circle size mapping to each point based on its quarter_numeric_factor\npoint_circle_sizes &lt;- circle_size_map[Sagaing_QuarterYear_Sf$quarter_numeric_factor]\n\n# Step 6: Plot the base map (Sagaing_Owin) without points\nplot(Sagaing_Owin, main = \"Sagaing Quarter-Year Owin with Unique Circle Sizes\")\n\n# Step 7: Add the points with the unique circle sizes based on quarter_numeric\npoints(coords[, 1], coords[, 2], cex = point_circle_sizes, pch = 16, col = \"black\")  # Add circles on top of base map\n\n# Step 8: Add a custom legend to show the quarter_numeric values and corresponding circle sizes\nlegend(\"topright\", legend = unique_quarters, \n       pch = 16, \n       pt.cex = circle_sizes,  # Show unique circle sizes in the legend\n       col = \"black\", \n       title = \"Quarters (Circle Size)\")\n\n\n\n\n\n\n\n\n\n\n\nSagaing_QuarterYear_PPP_Numeric &lt;- ppp(\n  x = coords[, 1],  # Longitude (x-coordinates)\n  y = coords[, 2],  # Latitude (y-coordinates)\n  window = Sagaing_Owin,  # Spatial window (Sagaing_Owin)\n  marks = Sagaing_QuarterYear_Sf$quarter_numeric  # Use numeric for KDE analysis (time-based)\n)\n\nSagaing_QuarterYear_KDE &lt;- spattemp.density(Sagaing_QuarterYear_PPP_Numeric)\n\nCalculating trivariate smooth...Done.\nEdge-correcting...Done.\nConditioning on time...Done.\n\nmulti_color_palette &lt;- colorRampPalette(c(\"blue\", \"green\", \"yellow\", \"red\"))\n\n\n# Define the quarters for which you want to plot the KDE\ntims &lt;- c(20211, 20212, 20213, 20214, 20221, 20222, 20223, 20224, \n          20231, 20232, 20233, 20234, 20241, 20242)\n\n#Set up the plotting window to display multiple plots in a grid (4 rows, 4 columns)\npar(mfrow=c(4, 4), mar=c(2, 2, 2, 2), oma=c(0, 0, 2, 0))  # Adjust margins and add outer margin for title\n\n# Loop through the 'tims' vector and plot the KDE for each time point (from left to right)\nfor(i in tims) { \n  plot(Sagaing_QuarterYear_KDE, i, \n       override.par=FALSE,  # Keep the graphical parameters unchanged\n       fix.range=TRUE,      # Fix the range of the KDE\n       main=paste(\"Quarter\", i),  # Title for each plot\n       ribside = \"right\", \n       col = multi_color_palette(100))  # Use 'inferno' color gradient\n  \n  # Remove the x and y axis labels for a cleaner look\n  axis(1, labels=FALSE)\n  axis(2, labels=FALSE)\n}\n\n#dd a unified title across all plots (e.g., the duration of analysis)\nmtext(\"Quarterly Spatio-Temporal KDE for Civilian Conflict Intensity in Sagaing\", \n      outer=TRUE, cex=1.5, font=2)\n\n\n\n\n\n\n\n\n\n\n\nmulti_color_palette &lt;- colorRampPalette(c(\"blue\", \"green\", \"yellow\", \"red\"))\n\n# Save the animation as a GIF\nsaveGIF({\n  # Loop over the valid quarter times\n  for(i in tims){ \n    suppressWarnings({\n      plot(Sagaing_QuarterYear_KDE, i, \n           override.par=FALSE,  # Keep graphical parameters unchanged\n           fix.range=TRUE,      # Fix the range of the KDE\n           main=paste(\"Sagaing Civilian Related Conflict KDE at Quarter\", i),  # Title for each plot\n           ribside = \"right\",  # Legend on the right\n           col = multi_color_palette(100))  # Apply multi-color gradient\n    })\n  }\n}, movie.name = \"Sagaingkde_animation.gif\", interval = 0.5, ani.width = 800, ani.height = 800)\n\n\nSpatio-Temporal KDE analysis for Sagaing across multiple quarters, we observe significant spatial clustering of civilian-related conflicts over time. The conflict intensity remains localized in specific regions, with fluctuations in density between quarters.\n\nKey Observations:\n\nConsistent Clustering: Conflict events are consistently clustered in the central and southern regions of Sagaing, as indicated by the green to red areas over time. These regions show recurring intensity, highlighting persistent conflict zones.\nTemporal Fluctuations: Some quarters, such as 20212, 20213, and 20222, exhibit relatively lower conflict intensity, while 20224 shows a resurgence in intensity.\nLocalized Hotspots: The southern region shows a spike in density during 20241, followed by a steady reduction in the later quarters.\n\n\n\nConclusion:\nThere is ongoing clustering in the same geographic regions of Sagaing, with peaks of conflict intensity in specific quarters. This indicates that while the overall distribution of conflicts remains stable, certain periods witness heightened violence."
  },
  {
    "objectID": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#yangon-7",
    "href": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#yangon-7",
    "title": "Take_Home Exercise 1: Geospatial Analytics for Social Good: Application of Spatial and Spatio-temporal Point Patterns Analysis to discover the geographical distribution of Armed Conflict in Myanmar",
    "section": "10.1 Yangon",
    "text": "10.1 Yangon\nFor the conflict events in Sagaing, we performed a detailed spatial point pattern analysis by computing the cross-K function for each pair of years (e.g., 2021 vs. 2022, 2021 vs. 2023, etc.). The cross-K function allows us to investigate how conflict events in one year relate to conflict events in another year, revealing whether the events are clustered, dispersed, or randomly distributed across space between different time periods.\n\nNull and Alternative Hypotheses:\n\nHo (Null Hypothesis): The distribution of conflict events in Yangon follows Complete Spatio-Temporal Randomness (CSTR), meaning the events are randomly distributed in both space and time.\nH1 (Alternative Hypothesis): The distribution of conflict events in Yangon does not follow CSTR and instead shows signs of clustering or dispersion in both space and time.\n\n\n\n10.1.1 Yangon’s Cross K Calculation\n\nCodeOutput and Charts\n\n\n\n# Create the spatial point pattern (ppp) object for Yangon\nYangon_ppp_years &lt;- ppp(\n  x = Yangon_ACLED_co[, 1],  # Longitude\n  y = Yangon_ACLED_co[, 2],  # Latitude\n  window = Yangon_Owin  # Spatial observation window (owin object)\n)\n\n# Add a mark that groups quarters by year (e.g., 2021, 2022, 2023, 2024)\nYangon_ppp_years$marks &lt;- as.factor(substr(Yangon_QuarterYear_Sf$quarter_numeric, 1, 4))\nYangon_ppp_years &lt;- rescale(Yangon_ppp_years, 1000, \"km\")\n# Store the unique years in the data\nunique_years &lt;- levels(Yangon_ppp_years$marks)\n\n# Function to compute cross-K function between two years\ncross_k_function_by_year &lt;- function(ppp_object, year1, year2) {\n  # Compute the cross-K function for the two selected years within the same ppp object\n  K_cross &lt;- Kcross(ppp_object, i = year1, j = year2)\n  return(K_cross)\n}\n\n# Initialize an empty list to store each year's comparison\nYangon_k_results &lt;- list()\n\n# Loop through pairs of years to compute and store cross-K functions\nfor (i in 1:(length(unique_years) - 1)) {\n  for (j in (i + 1):length(unique_years)) {\n    year1 &lt;- unique_years[i]\n    year2 &lt;- unique_years[j]\n    \n    # Print progress\n    cat(\"Computing K-Function for\", year1, \"and\", year2, \"\\n\")\n    \n    # Compute the cross-K function for these two years and store it in a named variable\n    result_name &lt;- paste0(\"Yangon_k_\", year1, \"_vs_\", year2)\n    Yangon_k_results[[result_name]] &lt;- cross_k_function_by_year(Yangon_ppp_years, year1, year2)\n  }\n}\n\n# Save individual year comparison results as variables\nYangon_k_2021_vs_2022 &lt;- Yangon_k_results[[\"Yangon_k_2021_vs_2022\"]]\nYangon_k_2021_vs_2023 &lt;- Yangon_k_results[[\"Yangon_k_2021_vs_2023\"]]\nYangon_k_2021_vs_2024 &lt;- Yangon_k_results[[\"Yangon_k_2021_vs_2024\"]]\nYangon_k_2022_vs_2023 &lt;- Yangon_k_results[[\"Yangon_k_2022_vs_2023\"]]\nYangon_k_2022_vs_2024 &lt;- Yangon_k_results[[\"Yangon_k_2022_vs_2024\"]]\nYangon_k_2023_vs_2024 &lt;- Yangon_k_results[[\"Yangon_k_2023_vs_2024\"]]\n\n# Set up the layout for multiple plots (2 rows, 3 columns for all year comparisons)\n\n\n\n\npar(mfrow = c(2, 1))\n# Plotting each comparison\nplot(Yangon_k_2021_vs_2022, main = \"K-Function: Yangon Civilian Related Conflict KDE 2021 vs 2022\")\nplot(Yangon_k_2021_vs_2023, main = \"K-Function: Yangon Civilian Related Conflict KDE 2021 vs 2023\")\n\n\n\n\n\n\n\nplot(Yangon_k_2021_vs_2024, main = \"K-Function: Yangon Civilian Related Conflict KDE 2021 vs 2024\")\nplot(Yangon_k_2022_vs_2023, main = \"K-Function: Yangon Civilian Related Conflict KDE 2022 vs 2023\")\n\n\n\n\n\n\n\nplot(Yangon_k_2022_vs_2024, main = \"K-Function: Yangon Civilian Related Conflict KDE 2022 vs 2024\")\nplot(Yangon_k_2023_vs_2024, main = \"K-Function: Yangon Civilian Related Conflict KDE 2023 vs 2024\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n10.1.2 Yangon’s Cross K Analysis\n\n10.1.2.1 Yangon’s Individual Years Comparision\n\n10.1.2.1.1 2021 vs 2022\n\n\nThe observed K-function lies consistently above the CSR envelope, indicating significant clustering between events from 2021 and 2022 at distances up to approximately 25 km.\nThe clustering effect becomes more prominent at larger distances, suggesting that events from 2021 tend to cluster with events from 2022 across larger spatial scales.\n\n\n\n10.1.2.1.2 2021 vs 2023\n\n\nThe K-function for 2021 vs 2023 is also above the CSR envelope, indicating clustering between these two years.\nHowever, the clustering is slightly less prominent compared to 2021 vs 2022, suggesting that while clustering persists, the relationship between events from 2021 and 2023 is somewhat weaker than between 2021 and 2022.\n\n\n\n10.1.2.1.3 2021 vs 2024\n\n\nThe clustering is still evident between 2021 and 2024, but the clustering intensity appears to be weaker at larger distances. The observed K-function shows less deviation from the CSR envelope, indicating that the spatial clustering effect is declining as we compare events separated by more time.\n\n\n\n10.1.2.1.4 2022 vs 2023\n\n\nThe K-function here indicates significant clustering at smaller distances, but the intensity decreases more rapidly beyond 15 km.\nThe spatial clustering between 2022 and 2023 is still present but somewhat weaker compared to other year-pair comparisons.\n\n\n\n10.1.2.1.5 2022 vs 2024\n\n\nThe 2022 vs 2024 K-function shows clustering, though it is less pronounced than in the previous year comparisons.\nThe clustering effect diminishes as the events from these two years become more spatially dispersed, particularly beyond 15 km.\n\n\n\n10.1.2.1.6 2023 vs 2024\n\n\nThe K-function for 2023 vs 2024 shows the least clustering effect of all the comparisons.\nThere is minimal deviation from the CSR line, indicating that the events from these two years are closer to being randomly distributed, with only mild clustering observed at smaller distances.\n\n\n\n\n10.1.2.1 Overall Years Comparison\n\nClustering is strongest between events that are closer in time (e.g., 2021 vs 2022), with the strength of clustering generally decreasing as the time difference between events increases (e.g., 2021 vs 2024).\nThis suggests that civilian conflict events in Yangon have a spatial-temporal dependence, where events in one year are more likely to occur near events from the following year, but this effect diminishes over time."
  },
  {
    "objectID": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#mandalay-7",
    "href": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#mandalay-7",
    "title": "Take_Home Exercise 1: Geospatial Analytics for Social Good: Application of Spatial and Spatio-temporal Point Patterns Analysis to discover the geographical distribution of Armed Conflict in Myanmar",
    "section": "10.2 Mandalay",
    "text": "10.2 Mandalay\nFor the conflict events in Mandalay, we performed a detailed spatial point pattern analysis by computing the cross-K function for each pair of years (e.g., 2021 vs. 2022, 2021 vs. 2023, etc.). The cross-K function allows us to investigate how conflict events in one year relate to conflict events in another year, revealing whether the events are clustered, dispersed, or randomly distributed across space between different time periods.\n\nNull and Alternative Hypotheses:\n\nHo (Null Hypothesis): The distribution of conflict events in Mandalay follows Complete Spatio-Temporal Randomness (CSTR), meaning the events are randomly distributed in both space and time.\nH1 (Alternative Hypothesis): The distribution of conflict events in Mandalay does not follow CSTR and instead shows signs of clustering or dispersion in both space and time.\n\n\n\n10.2.1 Mandalay’s Cross K Calculation\n\nCodeOutput and Charts\n\n\n\n# Create the spatial point pattern (ppp) object for Mandalay\nMandalay_ppp_years &lt;- ppp(\n  x = Mandalay_ACLED_co[, 1],  # Longitude\n  y = Mandalay_ACLED_co[, 2],  # Latitude\n  window = Mandalay_Owin  # Spatial observation window (owin object)\n)\n\n# Add a mark that groups quarters by year (e.g., 2021, 2022, 2023, 2024)\nMandalay_ppp_years$marks &lt;- as.factor(substr(Mandalay_QuarterYear_Sf$quarter_numeric, 1, 4))\n# Store the unique years in the data\nunique_years &lt;- levels(Mandalay_ppp_years$marks)\nMandalay_ppp_years &lt;- rescale(Mandalay_ppp_years, 1000, \"km\")\n\n# Function to compute cross-K function between two years\ncross_k_function_by_year &lt;- function(ppp_object, year1, year2) {\n  # Compute the cross-K function for the two selected years within the same ppp object\n  K_cross &lt;- Kcross(ppp_object, i = year1, j = year2)\n  return(K_cross)\n}\n\n# Initialize an empty list to store each year's comparison\nMandalay_k_results &lt;- list()\n\n# Loop through pairs of years to compute and store cross-K functions\nfor (i in 1:(length(unique_years) - 1)) {\n  for (j in (i + 1):length(unique_years)) {\n    year1 &lt;- unique_years[i]\n    year2 &lt;- unique_years[j]\n    \n    # Print progress\n    cat(\"Computing K-Function for\", year1, \"and\", year2, \"\\n\")\n    \n    # Compute the cross-K function for these two years and store it in a named variable\n    result_name &lt;- paste0(\"Mandalay_k_\", year1, \"_vs_\", year2)\n    Mandalay_k_results[[result_name]] &lt;- cross_k_function_by_year(Mandalay_ppp_years, year1, year2)\n  }\n}\n\n# Save individual year comparison results as variables\nMandalay_k_2021_vs_2022 &lt;- Mandalay_k_results[[\"Mandalay_k_2021_vs_2022\"]]\nMandalay_k_2021_vs_2023 &lt;- Mandalay_k_results[[\"Mandalay_k_2021_vs_2023\"]]\nMandalay_k_2021_vs_2024 &lt;- Mandalay_k_results[[\"Mandalay_k_2021_vs_2024\"]]\nMandalay_k_2022_vs_2023 &lt;- Mandalay_k_results[[\"Mandalay_k_2022_vs_2023\"]]\nMandalay_k_2022_vs_2024 &lt;- Mandalay_k_results[[\"Mandalay_k_2022_vs_2024\"]]\nMandalay_k_2023_vs_2024 &lt;- Mandalay_k_results[[\"Mandalay_k_2023_vs_2024\"]]\n\n\n\n\n# Set up the layout for multiple plots (2 rows, 3 columns for all year comparisons)\npar(mfrow = c(2, 1))\n\n# Plotting each comparison\nplot(Sagaing_k_2021_vs_2022, main = \"K-Function: Sagaing Civilian Related Conflict KDE 2021 vs 2022\")\nplot(Sagaing_k_2021_vs_2023, main = \"K-Function: Sagaing Civilian Related Conflict KDE 2021 vs 2023\")\n\n\n\n\n\n\n\nplot(Sagaing_k_2021_vs_2024, main = \"K-Function: Sagaing Civilian Related Conflict KDE 2021 vs 2024\")\nplot(Sagaing_k_2022_vs_2023, main = \"K-Function: Sagaing Civilian Related Conflict KDE 2022 vs 2023\")\n\n\n\n\n\n\n\nplot(Sagaing_k_2022_vs_2024, main = \"K-Function: Sagaing Civilian Related Conflict KDE 2022 vs 2024\")\nplot(Sagaing_k_2023_vs_2024, main = \"K-Function: Sagaing Civilian Related Conflict KDE 2023 vs 2024\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n10.2.2 Mandalay’s Cross K Analysis\n\n10.2.2.1 Mandalay’s Individual Years Comparison\n\n10.1.2.1.1 2021 vs 2022\n\n\nThe K-function for 2021 vs 2022 shows significant clustering at all distances. The observed K-function is consistently above the CSR envelope, indicating that conflict events from 2021 tend to cluster near those from 2022.\nThe clustering effect appears to intensify as the distance increases, suggesting a broad spatial clustering pattern for conflicts in 2021 and 2022.\n\n\n\n10.2.2.1.2 2021 vs 2023\n\n\nthe K-function for 2021 vs 2023 also shows clustering, but it is slightly less pronounced than in the 2021 vs 2022 comparison.\nThe clustering becomes more noticeable at distances beyond 10 km, implying that conflict events from these two years tend to cluster over medium to larger distances.\nHowever, the clustering effect weakens somewhat compared to the previous year comparison.\n\n\n\n10.2.2.1.3 2021 vs 2024\n\n\nClustering between 2021 and 2024 is still present, but the intensity is weaker compared to the previous year pairs.\nThe observed K-function does show some clustering above the CSR line, but the deviation from randomness is smaller, suggesting that events from 2021 and 2024 are less spatially related than the closer years (2021 vs 2022).\n\n\n\n10.2.2.1.4 2022 vs 2023\n\n\nThe clustering between 2022 and 2023 remains significant, especially at larger distances, with the observed K-function clearly above the CSR envelope.\nSimilar to earlier comparisons, this suggests that conflict events from these two years cluster over wider distances, continuing the spatial clustering trend seen in other comparisons.\n\n\n\n10.2.2.5 2022 vs 2024\n\n\nThe 2022 vs 2024 K-function shows clustering, although the intensity is weaker, particularly at smaller distances.\nThere is a slight increase in clustering at larger distances, but the deviation from the CSR envelope is less pronounced compared to the earlier year comparisons.\n\n\n\n10.2.2.6 2023 vs 2024\n\n\nThe K-function for 2023 vs 2024 shows clustering, though this is the weakest of all the comparisons.\nThe clustering effect becomes more noticeable at distances greater than 10 km, but overall, the spatial relationship between events from 2023 and 2024 is closer to random compared to earlier year comparisons.\n\n\n\n\n10.2.2.1 Mandalay Overall Years Comparison\n\nSimilar to the Yangon analysis, the spatial clustering is strongest between conflict events that are closer in time, such as 2021 vs 2022 and 2022 vs 2023.\nAs the time gap between years increases, the clustering effect becomes weaker, with the least clustering observed between 2023 and 2024.\n\nThese results suggest that conflicts in Mandalay show spatio-temporal clustering, with events from one year often clustering near those from the next, but this effect diminishes as the time gap between years grows."
  },
  {
    "objectID": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#sagaing-6",
    "href": "Take_Home_Exercises/Take_Home_Exercise_1/Take_Home_Exercise1.html#sagaing-6",
    "title": "Take_Home Exercise 1: Geospatial Analytics for Social Good: Application of Spatial and Spatio-temporal Point Patterns Analysis to discover the geographical distribution of Armed Conflict in Myanmar",
    "section": "10.3 Sagaing",
    "text": "10.3 Sagaing\nFor the conflict events in Sagaing, we performed a detailed spatial point pattern analysis by computing the cross-K function for each pair of years (e.g., 2021 vs. 2022, 2021 vs. 2023, etc.). The cross-K function allows us to investigate how conflict events in one year relate to conflict events in another year, revealing whether the events are clustered, dispersed, or randomly distributed across space between different time periods.\nNull and Alternative Hypotheses:\n\nHo (Null Hypothesis): The distribution of conflict events in Sagaing follows Complete Spatio-Temporal Randomness (CSTR), meaning the events are randomly distributed in both space and time.\nH1 (Alternative Hypothesis): The distribution of conflict events in Sagaing does not follow CSTR and instead shows signs of clustering or dispersion in both space and time.\n\n\n10.3.1 Sagaing’s Cross K Calculation\n\nCodeOutput and Charts\n\n\n\nSagaing_ppp_years &lt;- ppp(\n  x = Sagaing_ACLED_co[, 1],  # Longitude\n  y = Sagaing_ACLED_co[, 2],  # Latitude\n  window = Sagaing_Owin  # Spatial observation window (owin object)\n)\n\n# Add a mark that groups quarters by year (e.g., 2021, 2022, 2023, 2024)\nSagaing_ppp_years$marks &lt;- as.factor(substr(Sagaing_QuarterYear_Sf$quarter_numeric, 1, 4))\nSagaing_ppp_years &lt;- rescale(Sagaing_ppp_years, 1000, \"km\")\n# Store the unique years in the data\nunique_years &lt;- levels(Sagaing_ppp_years$marks)\n\n# Function to compute cross-K function between two years\ncross_k_function_by_year &lt;- function(ppp_object, year1, year2) {\n  # Compute the cross-K function for the two selected years within the same ppp object\n  K_cross &lt;- Kcross(ppp_object, i = year1, j = year2)\n  return(K_cross)\n}\n\n# Initialize an empty list to store each year's comparison\nSagaing_k_results &lt;- list()\n\n# Loop through pairs of years to compute and store cross-K functions\nfor (i in 1:(length(unique_years) - 1)) {\n  for (j in (i + 1):length(unique_years)) {\n    year1 &lt;- unique_years[i]\n    year2 &lt;- unique_years[j]\n    \n    # Print progress\n    cat(\"Computing K-Function for\", year1, \"and\", year2, \"\\n\")\n    \n    # Compute the cross-K function for these two years and store it in a named variable\n    result_name &lt;- paste0(\"Sagaing_k_\", year1, \"_vs_\", year2)\n    Sagaing_k_results[[result_name]] &lt;- cross_k_function_by_year(Sagaing_ppp_years, year1, year2)\n  }\n}\n\n# Save individual year comparison results as variables\nSagaing_k_2021_vs_2022 &lt;- Sagaing_k_results[[\"Sagaing_k_2021_vs_2022\"]]\nSagaing_k_2021_vs_2023 &lt;- Sagaing_k_results[[\"Sagaing_k_2021_vs_2023\"]]\nSagaing_k_2021_vs_2024 &lt;- Sagaing_k_results[[\"Sagaing_k_2021_vs_2024\"]]\nSagaing_k_2022_vs_2023 &lt;- Sagaing_k_results[[\"Sagaing_k_2022_vs_2023\"]]\nSagaing_k_2022_vs_2024 &lt;- Sagaing_k_results[[\"Sagaing_k_2022_vs_2024\"]]\nSagaing_k_2023_vs_2024 &lt;- Sagaing_k_results[[\"Sagaing_k_2023_vs_2024\"]]\n\n# Save individual year comparison results as variables\nSagaing_k_2021_vs_2022 &lt;- Sagaing_k_results[[\"Sagaing_k_2021_vs_2022\"]]\nSagaing_k_2021_vs_2023 &lt;- Sagaing_k_results[[\"Sagaing_k_2021_vs_2023\"]]\nSagaing_k_2021_vs_2024 &lt;- Sagaing_k_results[[\"Sagaing_k_2021_vs_2024\"]]\nSagaing_k_2022_vs_2023 &lt;- Sagaing_k_results[[\"Sagaing_k_2022_vs_2023\"]]\nSagaing_k_2022_vs_2024 &lt;- Sagaing_k_results[[\"Sagaing_k_2022_vs_2024\"]]\nSagaing_k_2023_vs_2024 &lt;- Sagaing_k_results[[\"Sagaing_k_2023_vs_2024\"]]\n\n\n\n\npar(mfrow = c(2, 1))\n# Plotting each comparison\nplot(Sagaing_k_2021_vs_2022, main = \"K-Function: Sagaing Civilian Related Conflict KDE 2021 vs 2022\")\nplot(Sagaing_k_2021_vs_2023, main = \"K-Function: Sagaing Civilian Related Conflict KDE 2021 vs 2023\")\n\n\n\n\n\n\n\nplot(Sagaing_k_2021_vs_2024, main = \"K-Function: Sagaing Civilian Related Conflict KDE 2021 vs 2024\")\nplot(Sagaing_k_2022_vs_2023, main = \"K-Function: Sagaing Civilian Related Conflict KDE 2022 vs 2023\")\n\n\n\n\n\n\n\nplot(Sagaing_k_2022_vs_2024, main = \"K-Function: Sagaing Civilian Related Conflict KDE 2022 vs 2024\")\nplot(Sagaing_k_2023_vs_2024, main = \"K-Function: Sagaing Civilian Related Conflict KDE 2023 vs 2024\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n10.3.2 Sagaing’s Cross K Analysis\n\n10.3.2.1 Sagaing’s Individual Years Comparison\n\n10.3.2.1.1 2021 vs 2022\n\n\nThe observed K-function r is consistently higher than the CSR (Complete Spatial Randomness) envelope across almost all distances. This indicates that the conflict events in 2021 and 2022 are significantly clustered in space. The clustering effect becomes more pronounced at larger distances, especially after 20 km.\nThe trans K-function also follows a similar pattern, showing clustering beyond the expected CSR pattern.\nThe Kbord function demonstrates that boundary corrections had minimal impact on the general clustering trends observed.\n\n\n\n10.3.2.1.2 2021 vs 2023\n\n\nSimilar to the comparison between 2021 and 2022, the K-function in 2021 vs 2023 also shows a high degree of clustering, with obs(r) being higher than CSR across nearly all distances.\nThere is a slightly more pronounced clustering effect around 30 to 40 km, where the gap between the observed K and CSR becomes wider. This suggests an increase in conflict density over time.\n\n\n\n10.3.2.1.3 2021 vs 2024\n\n\nthe K-function for 2021 vs 2024 shows a consistent pattern of clustering across distances, although the observed values tend to rise more sharply after 40 km, indicating that conflicts in 2024 were more dispersed initially but clustered significantly at larger spatial scales.\nThe results suggest that the spatial distribution of conflicts in 2024 is slightly different, possibly influenced by external factors that caused conflicts to be more spread out in space.\n\n\n\n10.3.2.1.4 2022 vs 2023\n\n\nThe comparison between 2022 and 2024 reveals strong clustering over a wide range of distances, with significant increases after 30 km.\nThis suggests that conflicts in 2024 are more spatially concentrated at larger distances compared to 2022.\n\n\n\n10.3.2.1.5 2022 vs 2024\n\n\nThe comparison between 2022 and 2024 reveals strong clustering over a wide range of distances, with significant increases after 30 km.\nThis suggests that conflicts in 2024 are more spatially concentrated at larger distances compared to 2022.\n\n\n\n10.3.2.1.6 2023 vs 2024\n\n\nThe clustering trend continues between 2023 and 2024, with notable increases in clustering beyond 40 km. The gap between the observed K and CSR remains large, indicating that the conflict events in 2023 and 2024 were not randomly distributed but exhibited significant spatial clustering.\n\n\n\n\n10.3.2.1 Sagaing Overall Years Comparison\n\nAcross all years (2021-2024), the K-functions suggest that civilian-related conflict events in Sagaing are significantly clustered rather than randomly distributed. The degree of clustering varies slightly across the years, with some years (such as 2024) showing stronger clustering at larger distances (over 40 km). This indicates that the conflict dynamics in Sagaing are evolving over time, possibly due to changes in political, social, or environmental factors."
  },
  {
    "objectID": "template.html",
    "href": "template.html",
    "title": "In Class Exercise 1: Geospatial Data Science",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "Take_Home_Exercises/Take_Home_Exercise_2/Take_Home_Exercise2.html",
    "href": "Take_Home_Exercises/Take_Home_Exercise_2/Take_Home_Exercise2.html",
    "title": "In Class Exercise1: Geospatial Data Science",
    "section": "",
    "text": "There’s no In Class Exercise 1, so here’s a picture of a cat."
  },
  {
    "objectID": "Take_Home_Exercises/Take_Home_Exercise_3/Take_Home_Exercise3.html",
    "href": "Take_Home_Exercises/Take_Home_Exercise_3/Take_Home_Exercise3.html",
    "title": "In Class Exercise1: Geospatial Data Science",
    "section": "",
    "text": "There’s no In Class Exercise 1, so here’s a picture of a cat."
  }
]